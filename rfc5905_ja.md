# Network Time Protocol Version 4：プロトコルとアルゴリズムの仕様

## 要旨

Network Time Protocol(NTP)は、インターネットでコンピュータの時刻を同期させるために広く使用されています。この文書では、以前のバージョンのプロトコルと同様に、[RFC 1305](https://tools.ietf.org/html/rfc1305)で説明されているNTPバージョン3(NTPv3)と下位互換性のあるNTPバージョン4(NTPv4)について説明します。NTPv4では、インターネットプロトコルバージョン6アドレスファミリーに対応したプロトコルヘッダーの変更が組み込まれています。NTPv4では、現代のワークステーションと高速LANを使用して精度を数十マイクロ秒に高める緩和アルゴリズムおよび規律アルゴリズムの根本的な改善が組み込まれています。このアルゴリズムには、動的サーバー検出スキームが組み込まれているため、多くの場合で、特定のサーバー構成は必要ありません。このアルゴリズムには、NTPv3の設計と実装における障害の修正と、任意の拡張メカニズムが組み込まれています。

## このメモの位置付け

これはインターネット標準化文書です。

この文書は、Internet Engineering Task Force(IETF)のプロダクトです。それはIETFコミュニティの合意を表しています。パブリックレビューを受けており、IESG(Internet Engineering Steering Group)の発行承認を受けています。インターネット標準の詳細については、[RFC 5741 2章](https://tools.ietf.org/html/rfc5741#section-2)を参照してください。

本書の位置付け、正誤表、フィードバックの提供方法については、http://www.rfc-editor.org/info/rfc5905 を参照してください。

## 著作権表記

Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.

この文書は[BCP 78](https://tools.ietf.org/html/bcp78)とIETF TrustのIETF文書に関する法律(http://trustee.ietf.org/license-info)の対象となります。これらの文書には、この文書に関するあなたの権利と制限が明記されているので、慎重に検討してください。この文書から抽出されたコードコンポーネントには、信託法の4章e節で説明されているSimplified BSD Licenseが含まれていなければなりません。また、Simplified BSD Licenseに記述されているように無保証で提供されます。

この文書には、2008年11月10日より前に発行、または一般公開されたIETF文書、IETF投稿の資料が含まれている場合があります。この資料の一部で著作権者は、IETF TrustがIETF標準プロセス以外での変更を許可していない可能性があります。そのような資料の著作権者から適切なライセンスを得ることなく、この文書をIETF標準プロセス以外で修正することはできず、この文書の派生もIETF標準プロセス外で作成することはできません。ただし、RFCとしての公開、または英語以外の言語に翻訳することはできます。

## 1. はじめに

この文書では、Network Time Protocol バージョン4(NTPv4)を定義しています。NTPv4は、分散したタイムサーバとクライアントの間でシステムクロックを同期させるために広く使用されています。この文書では、コアアーキテクチャ、プロトコル、ステートマシン、データ構造、アルゴリズムについて説明します。NTPv4は[[RFC1305](https://tools.ietf.org/html/rfc1305)]で説明されているNTPv3に新しい機能を導入し、その機能は[[RFC4330](https://tools.ietf.org/html/rfc4330)]で説明されているSimple NTPバージョン4(SNTPv4)から拡張されました(SNTPv4はNTPv4の一部です)。この文書は[[RFC1305](https://tools.ietf.org/html/rfc1305)]と[[RFC4330](https://tools.ietf.org/html/rfc4330)]を棄却します。一部のプロトコルヘッダーフィールドでいくつか変更が加えられましたが、NTPv4と以前のバージョンのNTPおよびSNTPとの相互運用性には影響しません。

NTPサブネットモデルには、有線または無線で国内標準と同期した、多数の広くアクセス可能なプライマリタイムサーバーで構成されています。NTPプロトコルの目的は、プライベートネットワークとパブリックインターネットの両方を介して、これらのプライマリサーバーからのタイムキーピング情報をセカンダリタイムサーバーおよびクライアントに伝えることです。適切に調整されたアルゴリズムは、ネットワークの中断、サーバーの障害、および敵対的と思われる動作によって発生しうるエラーを緩和します。サーバーとクライアントは、枝分かれしたセカンダリサーバー経由でルートのプライマリサーバーからクライアントに向かって値が流れるように構成されています。

NTPv4の設計には、NTPv3の設計の重大な欠点の克服、いくつかのバグ修正、新しい機能が組み込まれています。特に、拡張されたNTPタイムスタンプの定義は、実装全体を通じて倍精度浮動小数点数型の使用を推奨します。その結果、時間分解能は1ナノ秒より高く、周波数分解能は1秒当たり1ナノ秒未満となります。追加の改善点には、システムクロックハードウェアの周波数変動よりも応答性の高い新しいクロック規律アルゴリズムが含まれています。現代のマシンが使用する一般的なプライマリサーバーの精密さは数十マイクロ秒以内です。一般的なセカンダリサーバーと高速LAN上のクライアントでは数百マイクロ秒以内で、最大1024秒のポーリング間隔があり、これはNTPv3では最大の間隔です。NTPv4の場合、サーバーとクライアントの精密さは数十ミリ秒以内で、ポーリング間隔は最大36時間です。

この文書の本文では、準拠している実装間で相互運用するために必要なコアプロトコルとデータ構造について説明します。[付録A](https://tools.ietf.org/html/rfc5905#appendix-A)には、コアアルゴリズムのデータ構造とコードセグメント、信頼性と精度を向上させるための緩和アルゴリズムを含む全機能を備えた事例がスケルトンプログラムの形式で記載されています。スケルトンプログラムおよびその他の記述は、特定の実装に適用されていますが、必須機能を実装できる唯一の方法ではありません。[付録A](https://tools.ietf.org/html/rfc5905#appendix-A)の内容は、プロトコルの動作を説明するために設計された非規範的な例であり、適合する実装の要件ではありません。この文書で説明されるNTPv3共通鍵認証方式はNTPv3から引き継がれていますが、NTPv4の新しいAutokey公開鍵認証方式は[[RFC5906](https://tools.ietf.org/html/rfc5906)]に記載されています。

NTPプロトコルは、[2章](https://tools.ietf.org/html/rfc5905#section-2)で説明する動作モードで構成されており、[6章](https://tools.ietf.org/html/rfc5905#section-6)で説明するデータ型と[7章](https://tools.ietf.org/html/rfc5905#section-7)で説明するデータ構造が使用されています。[5章](https://tools.ietf.org/html/rfc5905#section-5)で説明する実装モデルは、スレッド化されたマルチプロセスアーキテクチャに基づいていますが、他のアーキテクチャでも同様に使用できます。[8章](https://tools.ietf.org/html/rfc5905#section-8)で説明するon-wireプロトコルは、測定されたクロックオフセットにのみに依存するリターナブルな時間設計に基づいていますが、信頼性のあるメッセージ配信は必須としません。TCP[[RFC0793](https://tools.ietf.org/html/rfc0793)]のような信頼性の高いメッセージ配信は、再試行が遅延値や他のエラーを増加させるため、配信されるNTPパケットの信頼性を低下させる可能性があります。同期サブネットは、最短パススパニングツリーと定義されたメトリックによって決定される同期パスを持つ、自己組織化、階層型のマスタースレーブネットワークです。複数のマスター(プライマリサーバー)が存在する可能性がありますが、選出プロトコルの要件はありません。

この文書には、[[ref9](https://tools.ietf.org/html/rfc5905#ref-ref9)]の資料が含まれています。この資料には、RFC形式に適さないフローチャートと式が含まれています。[[ref7](https://tools.ietf.org/html/rfc5905#ref-ref7)]には、この文書のプロトコルとアルゴリズムの広範な技術的分析と性能評価を含む多くの追加情報があります。リファレンス実装は www.ntp.org から入手できます。

以降のこの文書には、多数の変数と数式が含まれています。いくつかの変数は、大文字と小文字を区別した名前で綴られたギリシャ文字の形式をとります。たとえば、`DELTA`は大文字のギリシャ文字を表し、`delta`は小文字のギリシャ文字を表します。さらに、添字は '_'で表されます。たとえば、`theta_i`は小文字のギリシャ文字`theta`を指し、添え字iまたは音声的な`theta sub i`を指します。この文書では、すべての時間値は秒単位であり、すべての周波数は分数周波数オフセット(FFO)(純粋数)として指定されます。これらのFFOは百万分率(ppm)で表すと扱いやすい場合があります。

## 1.1. 要件記法

この文書のキーワード "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY"、"OPTIONAL" は[[RFC2119](https://tools.ietf.org/html/rfc2119)]で説明されているように解釈されます。

## 2. 動作モード

NTP実装は、プライマリサーバー、セカンダリサーバー、またはクライアントとして動作します。プライマリサーバーは、UTCに直接追従可能な１次参照源と同期します(GPS、ガリレオなど)。クライアントは1つ以上の上位サーバーと同期しますが、他のクライアントへの同期は提供しません。セカンダリサーバーは、1つ以上の上位サーバーと1つ以上の下位サーバーまたはクライアントを持ちます。NTPv4に完全準拠しているすべてのサーバーとクライアントは、この文書で説明しているアルゴリズムスイート全体を実装しなければなりません。大規模なNTPサブネットの安定性を維持するために、セカンダリサーバーはNTPv4に完全準拠する必要があります(SHOULD)。代替アルゴリズムを使用してもよい(MAY)が、その出力結果はこの仕様で説明されているアルゴリズムと同一でなければいけません(MUST)。

## 3.プロトコルモード

対称型、クライアント/サーバー型、ブロードキャスト型の3種類のNTPプロトコルがあります。それぞれ、図1に示すように、アソシエーションモード(2つのNTPスピーカー間の関係の説明)に関連付けられています。さらに、永続的アソシエーションは起動時に確立され、決して変更されません。一時的アソシエーションは、パケット到着時に確立され、エラーまたはタイムアウト時に解除されます。

 |  アソシエーションモード      | アソシエーションモード値 | パケットモード値 |
 |------------------------------|--------------------------|------------------|
 | 対称アクティブ               |         1                | 1 or 2           |
 | 対称パッシブ                 |         2                | 1                |
 | クライアント                 |         3                | 4                |
 | サーバー                     |         4                | 3                |
 | ブロードキャストサーバー     |         5                | 5                |
 | ブロードキャストクライアント |         6                | N/A              |

```
                  図1：アソシエーションモードとパケットモード
```

クライアント/サーバー型では、永続的にクライアントはパケットモード4のパケットをサーバーに送信し、パケットモード3のパケットを返します。サーバーは1つ以上のクライアントに同期を提供しますが、同期は受け付けません。サーバーは、GPS受信機や電話モデムサービスなどの標準ソースから直接時間を取得する１次参照源ドライバでもあります。この形式では、クライアントはサーバーから同期を取り込みます。

対称型では、ピアは対称アクティブまたは対称パッシブアソシエーションのいずれかを使用して、サーバーとクライアントの両方として動作します。永続的対称アクティブアソシエーションは、対称アクティブ(モード1)パケットを対称アクティブピアアソシエーションに送信します。一時的対称パッシブアソシエーションは、一致するアソシエーションのない対称アクティブパケットの到着時に決定されます。このアソシエーションは対称パッシブ(モード2)パケットを送信し、エラーまたはタイムアウトまで継続します。ピアは、互いの間で同期をプッシュおよびプルします。この文書の目的上、ピアはクライアントのように動作するため、クライアントへの参照はピアを暗示しています。

ブロードキャスト型において、永続的ブロードキャストサーバーアソシエーションは、複数のクライアントが受信できる定期的なブロードキャストサーバー(モード5)パケットを送信します。一致するアソシエーションのないブロードキャストサーバーパケットを受信すると、一時的ブロードキャストクライアント(モード6)アソシエーションが確立され、エラーまたはタイムアウトまで継続します。クライアントがブロードキャストクライアントモードに復帰した後、クライアントモードで動作しているクライアントがサーバーと複数回パケットを交換し、伝播遅延を較正して、Autokeyセキュリティプロトコルを実行するために、初期ボレーを提供すると都合がいいです。ブロードキャストサーバーは、クライアントや他のサーバーに同期をプッシュします。

電話業界によって確立された規約に準拠すると、階層内の各サーバーのレベルは階層番号によって定義されます。プライマリサーバーには階層1が割り当てられます。各下位レベルの2次サーバーには、前のレベルより1つ大きい階層番号が割り当てられます。階層数が増えると、特定のネットワークパスとシステムクロックの安定性によって精度が低下します。同期距離によって測定される平均誤差は、層数および測定された往復遅延にほぼ比例して増加します。

標準的な手法として、タイミング・ネットワーク・トポロジは、タイミング・ループを回避し、同期距離を最小化するように構成する必要があります。NTPでは、プライマリサーバーをルートとする最短パススパニングツリーを計算するBellman-Ford分散ルーティングアルゴリズムの変種を使用して、サブネットトポロジが決定されます。この設計の結果、アルゴリズムは、タイミングネットワークに障害がある場合でも、最も正確で信頼性の高い時間を配信するように、サブネットを自動的に再編成します。

## 3.1. 動的サーバー検出

動的サーバー検出機能を提供する2つの特別なアソシエーションとして、メニーキャストクライアントとメニーキャストサーバーがあります。メニーキャストクライアントのアソシエーションには、永続型と一時型の2種類があります。永続的メニーキャストクライアントは、クライアント(モード3)パケットを指定されたIPv4またはIPv6のブロードキャストまたはマルチキャストグループアドレスに送信します。パケットヘッダーのTTL(Time-To-Live)フィールドの範囲内にある指定されたメニーキャストサーバーは、そのアドレスを持つパケットをリッスンします。サーバーが同期に適している場合、サーバーはクライアントのユニキャストアドレスを使用して通常のサーバー(モード4)パケットを返します。このパケットを受信すると、クライアントは一時的クライアント(モード3)のアソシエーションとして確立されます。一時的クライアントのアソシエーションは、エラーまたはタイムアウトまで継続します。

メニーキャストクライアントは、最小数のアソシエーションを検索するために、パケットを継続して送信します。これは、TTLを1から始めて、最小数のアソシエーションが確立されるか、TTLが最大値に達するまで、継続的にTTLに1が加算されていきます。TTLが最大値に達したにもかかわらず十分なアソシエーションが確立されていない場合、クライアントはすべてのアソシエーションをクリアするため、タイムアウト期間での送信を停止し、検索サイクルを繰り返します。最小数のアソシエーションが確立された場合、クライアントはアソシエーションを維持するためにタイムアウト期間ごとに1つのパケットの送信を開始します。フィールドの制約として、最小値を1に、最大値を255に制限します。これらの制限は、個々のアプリケーションのニーズに合わせて調整できます。

一時的アソシエーションは彼ら自身の間で競争をします。新たな一時的アソシエーションが確立されると、クライアントは、[10章](https://tools.ietf.org/html/rfc5905#section-10)および[11章2節](https://tools.ietf.org/html/rfc5905#section-11.2)に記載された緩和アルゴリズムを実行し、残りの一時的アソシエーションはタイムアウトして解除されます。このようにして、集団はシステムクロックを統制するためのNTPパケットで直近に応答した最良の候補のみで構成されます。

## 4. 定義

この章ではいくつかの技術用語が定義されています。タイムスケールは参照フレームであり、時間は、単調に増加するバイナリカウンタの値として不定のビット数で表されます。小数点が使用された場合、それは秒の小数部とみなします。協定世界時(UTC)タイムスケールは、ITU-R TF.460 [[ITU-R_TF.460](https://tools.ietf.org/html/rfc5905#ref-ITU-R_TF.460)]で定義されています。1865年のメートル条約の保護下で、1975年の国際度量衡総会[[CGPM](https://tools.ietf.org/html/rfc5905#ref-CGPM)]では、市民の時間の基礎としてUTCの使用が強く支持されています。

協定世界時(UTC)の時間尺度は、国家基準試験所によって頒布された平均日照時間を表します。システム時刻は、ハードウェアおよびオペレーティングシステムによって維持されるシステムクロックによって表されます。NTPアルゴリズムの目的は、UTCとシステムクロックの時間差と周波数差の両方を最小限に抑えることです。これらの差異が公称公差よりも小さくなると、システムクロックはUTCに同期されたと言えます。

イベント日付は、イベントが発生するUTC時間です。日付は、大文字の`T`で指定された一時的な値です。稼働時間は、NTPプログラムの同期機能と一致する別のタイムスケールです。

タイムスタンプ`T(t)` は、UTCの日付か、稼働時間` t`におけるUTCからの時間オフセットを表します。どちら意味で使用されているのかは、文脈から明らかであるべきです。`T(t)`を時間オフセット、`R(t)` を周波数オフセット、`D(t)` を経時変化率(`t`に対する`R(t)` の一次導関数)とします。次に、`T(t_0)`が`t = t_0`で決定されたUTC時間オフセットである場合、時刻`t`におけるUTC時間オフセットは

$$ T(t) = T(t_0) + R(t_0)(t-t_0) + 1/2 * D(t_0)(t-t_0)^2 + e $$

となり、ここで、`e`はこの文書で後述する確率的誤差項です。精密オシレータを特徴付けるときは`D(t)`項が重要ですが、通常はコンピュータオシレータについては無視されます。この文書では、すべての時間値は秒単位であり、すべての周波数は`seconds-per-second(s/s)`です。周波数オフセットは`parts-per-million(ppm)`で表す方が扱いやすい場合があり、この場合、`1ppm`は`10^(-6) s/s`と等しいです。

コンピュータのタイムキーピングアプリケーションでは、タイムキーピング機能の性能を評価することが重要です。NTPパフォーマンスモデルは、クライアントがサーバーで測定を行うたびに更新される4つの統計で構成されています。オフセット(`theta`)は、システムクロックに対するサーバークロックの最尤時間オフセットを表します。遅延(`delta`)は、クライアントとサーバー間の往復遅延を表します。分散(`epsilon`)は、測定における固有の最大誤差を表します。これは、最大規律システムクロック周波数許容差(`PHI`)と等しい割合で増加し、通常は`15ppm`です。ジッタ(`psi`)は直近のオフセット差の二乗平均(RMS)として定義され、オフセットを推定する際の公称誤差を表します。

`theta`、`delta`、`epsilon`、および`psi`の統計値は、各サーバークロックに対するシステムクロックの測定値を別々に表していますが、NTPプロトコルには、複数のサーバーの統計情報を組み合わせてシステムクロックをより正確に調整し較正するメカニズムが組み込まれています。システムオフセット(`THETA`)は、サーバー集団の最尤オフセット推定値を表します。システムジッタ(`PSI`)は、システムオフセットを推定する際の公称誤差を表します。`delta` および `epsilon` の統計値は、１次参照源から各階層毎に累積され、ルート遅延(`DELTA`)およびルート分散(`EPSILON`)の統計値を生成します。`EPSILON + DELTA / 2`と等しい同期距離(`LAMBDA`)は、すべての要因における最大誤差を表します。これらの統計の詳細な公式は[11章2節](https://tools.ietf.org/html/rfc5905#section-11.2)で示されています。これらの統計値は、同期機能の性能を評価するために附属アプリケーションで使用できます。

## 5. 実装モデル

図2は、一般的なマルチスレッド実装のアーキテクチャを表しています。これは、各サーバー専用の2つのプロセス、サーバーまたは１次参照源からのメッセージを受信するピアプロセス、およびサーバーまたは１次参照源にメッセージを送信するためのポーリングプロセスで構成されています。

```
 .....................................................................................
 . リモート   .   ピア/ポーリング  .           システム              .  クロック     .
 . サーバー   .   プロセス         .           プロセス              .  規律         .
 .            .                    .                                 .  プロセス     .
 .+----------+. +-----------------+. +--------------+                .               .
 .|          |->|                 |. |              |                .               .
 .|サーバー 1|  |ピア/ポーリング 1|->|              |                .               .
 .|          |<-|                 |. |              |                .               .
 .+----------+. +-----------------+. |              |                .               .
 .            .          ^         . |              |                .               .
 .            .          |         . |              |                .               .
 .+----------+. +-----------------+. |              |  +------------+.               .
 .|          |->|                 |. |選択 および   |->|            |. +-----------+ .
 .|サーバー 2|  |ピア/ポーリング 2|->|クラスタ      |  |結合        |->| ループ    | .
 .|          |<-|                 |. |アルゴリズム  |  |アルゴリズム|. | フィルター| .
 .+----------+. +-----------------+. |              |->|            |. +-----------+ .
 .            .          ^         . |              |  +------------+.      |       .
 .            .          |         . |              |                .      |       .
 .+----------+. +-----------------+. |              |                .      |       .
 .|          |->|                 |. |              |                .      |       .
 .|サーバー 3|  |ピア/ポーリング 3|->|              |                .      |       .
 .|          |<-|                 |. |              |                .      |       .
 .+----------+. +-----------------+. +--------------+                .      |       .
 ........................^..................................................|........
                         |                                           .      V       .
                         |                                           .   +-----+    .
                         +-----------------------------------------------| VFO |    .
                                                                     .   +-----+    .
                                                                     .    クロック  .
                                                                     .    調整      .
                                                                     .    プロセス  .
                                                                     ................

                      図2：実装モデル
```

これらのプロセスは、アソシエーションと呼ばれる共通のデータ構造上で動作します。アソシエーションには、[9章](https://tools.ietf.org/html/rfc5905#section-9)で説明するその他のさまざまなデータとともに、前述の統計情報が含まれています。クライアントは、1つ以上のサーバーにパケットを送信し、サーバーは、送信元と宛先のアドレスとポートを交換し、パケットの特定のフィールドを上書きし、直ちに(クライアント/サーバーモードの場合)、またはしばらくした後に(対称モードの場合)返信します。各NTPメッセージが受信されると、ピアクロックとシステムクロックとの間のオフセット`theta` が、関連する統計量 `delta`、`epsilon`、および`psi`と共に計算されます。

システムプロセスには、システムクロックを同期させる最も正確で信頼性の高い候補を決定するために、さまざまなサーバーと１次参照源を緩和する選択アルゴリズム、クラスタアルゴリズム、および結合アルゴリズムで構成されています。選択アルゴリズムでは、ビザンチンの障害検出原理を使用して、インシデント集団から"falsetickers"と呼ばれる正確ではないと思われる候補を破棄し、"truechimers"と呼ばれる良好な候補のみを残します。truechimerは、事前に公開され信頼されている一次参照源とのタイムキーピングの精度を維持する時計であり、falsetickerは誤解を招く、または一貫性のない時間を示す時計です。クラスタアルゴリズムは、統計的な原理を使用して、最も正確なtruechimerを見つけます。結合アルゴリズムは、生き残ったtruechimerを統計的に平均することによって最終的なクロックオフセットを計算します。

クロック規律プロセスは、ここでは可変周波数発振器(VFO)として表されている、システムクロックの時間と周波数を制御するシステムプロセスです。VFOからのタイムスタンプは、システムクロックの時間を維持するフィードバックループに閉じています。クロック規律プロセスに関連するのはクロック調整プロセスであり、毎秒1回実行され、計算された時間オフセットを注入し、一定の周波数を維持します。過去の時間オフセット差のRMS平均値は、公称誤差またはシステムクロックジッタを表します。過去の周波数オフセット差のRMS平均は、発振器の周波数安定度または周波数変動を表します。これらの用語は、[11章3節](https://tools.ietf.org/html/rfc5905#section-11.3)で詳細に解説されています。

クライアントは、ポーリング指数`tau`によって決定される、`2^tau`秒のポーリング間隔で各サーバーにメッセージを送信します。NTPv4では、`tau`の範囲は`4(16秒)`から`17(36時間)`です。`tau`の値は、ループ時間定数`T_c = 2^tau`と一致するクロック規律アルゴリズムによって決定されます。クライアント/サーバーモードでは、サーバーはすぐに応答します。対称モードでは、2つのピアのそれぞれが現在のシステムオフセットとシステムジッタの関数として`tau`を管理しているため、値が一致しない場合があります。NTPサブネット全体の安定性を維持するためには、クロック規律アルゴリズムの動的挙動を注意深く制御することが重要です。これは、両方のピアの最小のポーリング指数に等しい共通の`tau`にピアが同意することを要求します。NTPプロトコルには、この値を適切にネゴシエートするための規定が組み込まれています。

実装モデルには、システムクロックを設定および調整する手段が組み込まれています。オペレーティングシステムには、次の2つの機能があります。1つはUnixの`settimeofday()`関数のように時刻を直接設定するもので、もう1つは、Unixの`adjtime()`関数のように指定された幅で時間を進めるか遅くするかを微調整するものです。以降の参考文献では、名前に続くカッコは、単純な変数ではなく関数を示しています。意図した設計では、クロック規律プロセスは、調整が指定された閾値よりも小さい場合は`adjtime()`関数を使用し、閾値より大きい場合は`settimeofday()`関数を使用します。このプロセスと閾値は、[10章](https://tools.ietf.org/html/rfc5905#section-10)で説明します。

## 6. データ型

すべてのNTP時間値は、2の補数形式で表現され、ビッグエンディアン方式([[RFC0791]の付録A](https://tools.ietf.org/html/rfc0791#appendix-A)に記載)で左側から順に0から順番に番号が振られます。図3に示すように、3つのNTPタイムフォーマット、128ビットの日付フォーマット、64ビットのタイムスタンプフォーマット、および32ビットのショートフォーマットがあります。128ビットの日付フォーマットは、十分なストレージとワードサイズが利用可能です。これには、5840億年分の64ビット符号付き秒フィールドと、0.05アト秒(すなわち、0.5e-18)を表現できる64ビット小数部フィールドがあります。フォーマット間のマッピングの便宜のために、秒フィールドは32ビットのEra ナンバーフィールドと32ビットのEra オフセットフィールドに分割されています。EraはNTPによって直接生成されることはなく、また、生成する必要もありません。必要に応じて、ファイルシステムや専用ハードウェアなどの外部から取得することができます。

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |            秒                 |            小数部             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                          NTPショートフォーマット

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                               秒                              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                             小数部                            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                        NTPタイムスタンプフォーマット

  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         Era ナンバー                          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         Era オフセット                        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |                             小数部                            |
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         NTP日付フォーマット

                    図3：NTPタイムフォーマット
```

64ビットのタイムスタンプフォーマットは、パケットヘッダーなどの限られたワードサイズの場所で使用されます。これは、136年分の32ビット符号なし秒フィールドと、232ピコ秒を表現できる32ビットの小数部フィールドで構成されています。32ビットのショートフォーマットは、他フォーマットとの完全な分解能および範囲の整合性が取れない、遅延および分散ヘッダーフィールドで使用されます。これは、16ビット符号なし秒フィールドと16ビット小数部フィールドで構成されています。

日付フォーマットとタイムスタンプフォーマットでは、すべてのビットが0である場合、起点日付、すなわちEra 0の基底日付は、1900年1月1日0時となります。厳密に言えば、UTCは1972年1月1日より前には存在していませんが、歴史的な閏秒に関するすべての知識が失われたとしても、それが永遠に存在していたと仮定するのに都合がいいです。日付は起点日付に関連しており、0より大きい値はその日付以降の時間を、0より小さい値はそれ以前の時間を表します。日付フォーマットのEra オフセットフィールドとタイムスタンプフォーマットの秒フィールドは同じ解釈をすることに注意してください。

タイムスタンプは符号なしの値で、その値は同じまたは隣接するEraの値から算出します。Era 0は、起点日付から、タイムスタンプフィールドが一周しEra 1の基準日となる、2036年のある日付までです。どのフォーマットでも、ゼロの値は、未知の時間または非同期の時間を表す特殊なケースです。図4は、対応する修正ユリウス日(MJD)、NTP Era、およびNTPタイムスタンプと一緒に、歴史的なNTPの日付をいくつか示しています。

 | 西暦 | MJD | NTP<br>Era | NTPタイムスタンプ<br>Era オフセット | 年代         |
 |----------------:|-----------:|----:|------------------:|---------------------|
 | -4712年 1月 1日 | -2,400,001 | -49 | 1,795,583,104     | ユリウス通日 初日   |
 |    -1年 1月 1日 | -679,306   | -14 | 139,775,744       | 紀元前2世紀         |
 |     0年 1月 1日 | -678,491   | -14 | 171,311,744       | 紀元前1世紀         |
 |     1年 1月 1日 | -678,575   | -14 | 202,939,144       | 1世紀               |
 |  1582年10月 4日 | -100,851   | -3  | 2,873,647,488     | ユリウス通日 最終日 |
 |  1582年10月15日 | -100,840   | -3  | 2,874,597,888     | グレゴリオ暦 初日   |
 |  1899年12月31日 | 15,019     | -1  | 4,294,880,896     | NTP Era -1 最終日   |
 |  1900年 1月 1日 | 15,020     | 0   | 0                 | NTP Era  0 初日     |
 |  1970年 1月 1日 | 40,587     | 0   | 2,208,988,800     | UNIX時間 初日       |
 |  1972年 1月 1日 | 41,317     | 0   | 2,272,060,800     | UTC 初日            |
 |  1999年12月31日 | 51,543     | 0   | 3,155,587,200     | 20世紀 最終日       |
 |  2036年 2月 8日 | 64,731     | 1   | 63,104            | NTP Era  1 初日     |

```
                             図4：歴史的なNTPの日付
```

`p`を2番目の端数の有効ビット数とすると、クロック分解能は`2^(-p)`秒で定義されます。バイアスを最小限に抑え、侵入者にタイムスタンプを予測させないようにするには、重要でないビットをバイアスのないランダムなビットストリングに設定する必要があります。クロック精度は、システムクロックを読み取るための実行時間(秒)で定義されます。このように定義された精度は、分解能よりも大きくても小さくてもよいことに注意してください。プロトコルで使用される精度を表す項`rho`は、2つのうち大きい方です。

日付とタイムスタンプで許される唯一の算術演算は、127ビットまたは63ビットの符号付きの計算結果になる2の補数減算です。2つの日付の間の1次の差異が完全な128ビットの精度を保持し、2つのタイムスタンプ間の1次の差異が完全な64ビットの精度を保持することが重要です。ただし、差異は通常、秒スパンに比べて小さいため、さらに倍精度浮動小数点数型に変換することで精度を損なうことなく処理することができます。2の補数演算は符号付きと符号なしの値を区別しないことに注意することが重要です。(ただし、比較には符号が考慮され、これは条件分岐命令だけが行います。)したがって、符号あり日付と符号なしタイムスタンプは区別されますが、同じ方法で処理されます。認知される危険として、これは2036年に起こりうるが、Eraを超えて64ビットタイムスタンプを計算すると、オーバーランが発生する可能性があります。実際には、プロトコルが開始される前にクライアントがサーバーの68年以内に設定されていれば、クライアントとサーバーが隣接するEra であっても正しい値が得られます。

いくつかの時間値は、精度、時定数、およびポーリング間隔を含む指数形式で表されます。これらは`log2`(ログベース2)秒の8ビット符号付き整数形式です。それらに対して許可される唯一の算術演算は増分と減分です。この文書では、プレゼンテーションを簡略化するために、これらを変数名のみで言う場合は、それは累乗された値、例えばポーリング間隔は1024秒を意味し、変数名と指数で言う場合は実際の値、例えばポーリング指数は10を意味します。

任意のフォーマットのシステム時刻をNTPの日付フォーマットとタイムスタンプフォーマットに変換するには、起点日付からシステム時刻までの秒数`s`を決定する必要があります。得られた`s`から整数値の`era`とタイムスタンプを決定するには、

$$ era = s / 2^{32} $$
$$ timestamp = s - era * 2^{32} $$

となり、これは正と負の日付で動作します。得られた`era`とタイムスタンプから`s`を決定するには、

$$ s = era * 2^{32} + timestamp $$

となります。NTPとシステム時間の変換は少し面倒で、この文書の範囲を超えています。なお、Era 0の日数は他のほとんどの時代の日数の1倍以上であり、これは、Era 3 の2400年まで再び起こりません。

以降の状態変数の説明では、整数型は32ビット符号なし整数を意味します。これは上限の定義が必要なためで、境界値チェックを簡素化するためです。明示的な言及がない場合、デフォルトの型は64ビット倍精度浮動小数点型です。必要に応じて例外が明示されます。

## 7. データ構造

以下の章では、NTP状態マシンが定義されています。状態変数は、パケットヘッダー、ピアおよびポーリングプロセス、システムプロセス、およびクロック規律プロセスにおけるそれらの機能に従ってそれぞれのクラスに分離されます。パケット変数は、送信パケットと受信パケットのNTPヘッダー値を表します。ピア変数とポーリング変数は、各サーバーのアソシエーションの内容を個別に表します。システム変数は、その従属クライアントによって参照されるサーバーの状態を表します。クロック規律変数は、クロック規律アルゴリズムの内部動作を表します。例については、[付録A](https://tools.ietf.org/html/rfc5905#appendix-A)を参照してください。

同じ名前の異なる変数を異なるプロセスで区別して使用するために、図5に要約されている命名規則が採用されています。受信パケット変数`v`は、完全修飾名`r.v`を持つパケット構造`r`のメンバーです。同様に、`x.v`は送信パケット変数、`p.v`はピア変数、`s.v`はシステム変数、`c.v`はクロック規律変数です。各アソシエーションに対してピア変数のセットがあります。システム変数とクロック変数のセットは1つだけです。

 | 名前 | 説明                     |
 |------|--------------------------|
 | r.   | 受信パケットヘッダー変数 |
 | x.   | 送信パケットヘッダー変数 |
 | p.   | ピア/ポーリング変数      |
 | s.   | システム変数             |
 | c.   | クロック規律変数         |

```
          図5：接頭辞の表記法
```

## 7.2. グローバルパラメータ

この文書では、変数クラスに加えて、図6の値で示されているものを含む、多くのグローバルパラメータが定義されています。

```
 | 名前      | 値    | 説明                      |
 +-----------+-------+---------------------------|
 | PORT      | 123   | NTPポート番号             |
 | VERSION   | 4     | NTPバージョン番号         |
 | TOLERANCE | 15e-6 | 周波数許容差 PHI (s/s)    |
 | MINPOLL   | 4     | 最小ポーリング指数 (16秒) |
 | MAXPOLL   | 17    | 最大ポーリング指数 (36時間) |
 | MAXDISP   | 16    | 最大分散 (16秒)           |
 | MINDISP   | .005  | 最小分散増分 (秒)          |
 | MAXDIST   | 1     | 距離閾値 (1秒)            |
 | MAXSTRAT  | 16    | 最大階層数                |
 +-----------+-------+---------------------------+

             図6：グローバルパラメータ
```

これらは相互運用性に必要な唯一のグローバルパラメータですが、より多くのコレクションが必要です。[付録A.1.1](https://tools.ietf.org/html/rfc5905#appendix-A.1.1)には、緩和アルゴリズム、クロック規律アルゴリズム、および関連するインプリメンテーション依存機能のためにスケルトンによって使用されるものが組み込まれています。これらのパラメータ値の中には、IANAによって割り当てられたNTPポート番号やNTPv4自体に割り当てられたバージョン番号など、一部がキャストされているものもあります。周波数許容差(PHIとも呼ばれる)のような他のものは、一度同期したシステムクロックの最悪の場合の動作についての仮定を含み、そのソースが到達不能になったときにドリフトすることが許されます。最小および最大パラメータは、この文書の後の章で説明するように、状態変数の限界を定義します。

この文書では固定値で示されていますが、実装によっては、設定コマンドによって変数を調整可能にする場合があります。例えば、参照実装では、`PRECISION`の値を、システムクロックを読み取るためのいくつかの反復における最小時間のlog2として計算します。

## 7.3. パケットヘッダー変数

外部視点からの最も重要な状態変数は、図7以下で説明するパケットヘッダー変数です。NTPパケットヘッダーは、整数の32ビット(4オクテット)のネットワークバイトオーダで構成されています。パケットフォーマットは、ヘッダー自身、1つ以上のオプションの拡張フィールド、およびオプションのメッセージ認証コード(MAC)の3つのコンポーネントで構成されます。ヘッダーコンポーネントは、NTPv3ヘッダーと以前のバージョンと同じです。オプションの拡張フィールドは、[[RFC5906](https://tools.ietf.org/html/rfc5906)]で説明されているAutokey公開鍵暗号アルゴリズムによって使用されます。オプションのMACは、このRFCで説明されているAutokeyと対称鍵暗号アルゴリズムの両方で使用されます。

```
 +-----------+------------+------------------------+
 | 一般名    | 数式名     | 説明                   |
 +-----------+------------+------------------------+
 | leap      | leap       | 閏秒インジケータ (LI)  |
 | version   | version    | バージョン番号 (VN)    |
 | mode      | mode       | モード                 |
 | stratum   | stratum    | 階層                   |
 | poll      | poll       | ポーリング指数         |
 | precision | rho        | 精度指数               |
 | rootdelay | delta_r    | ルート遅延             |
 | rootdisp  | epsilon_r  | ルート分散             |
 | refid     | refid      | 参照ID                 |
 | reftime   | reftime    | 参照タイムスタンプ     |
 | org       | T1         | 発信タイムスタンプ     |
 | rec       | T2         | 受信タイムスタンプ     |
 | xmt       | T3         | 送信タイムスタンプ     |
 | dst       | T4         | 宛先タイムスタンプ     |
 | keyid     | keyid      | 鍵識別子               |
 | dgst      | dgst       | メッセージダイジェスト |
 +-----------+------------+------------------------+

             図7：パケットヘッダー変数
```

NTPパケットはUDPデータグラム[[RFC0768](https://tools.ietf.org/html/rfc0768)]です。
いくつかのフィールドは複数の単語を使用し、他のフィールドは単語内の小さなフィールドにパックされます。図8に示すNTPパケットヘッダーには、オプションの拡張フィールドと最後にKey IdentifierフィールドとMessage Digestフィールドで構成されるオプションのメッセージ認証コード(MAC)が12ワード続きます。

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |LI | VN  |Mode |     階層      |     Poll      |     精度      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         ルート遅延                            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         ルート分散                            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         参照ID                                |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                      参照タイムスタンプ (64)                  +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                      発信タイムスタンプ (64)                  +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                      受信タイムスタンプ (64)                  +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                      送信タイムスタンプ (64)                  +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 .                                                               .
 .                    拡張フィールド 1 (任意)                    .
 .                                                               .
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 .                                                               .
 .                    拡張フィールド 2 (任意)                    .
 .                                                               .
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         鍵識別子                              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 |                メッセージダイジェスト (128)                   |
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                  図8：パケットヘッダーフォーマット
```

拡張フィールドは、Autokeyセキュリティプロトコル[[RFC5906](https://tools.ietf.org/html/rfc5906)]などのオプション機能を追加するために使用されます。拡張フィールドのフォーマットは、拡張フィールドの機能を知らずにパケットを解析するために提示されます。MACは、Autokeyと対称鍵認証方式の両方で使用されます。

図7に示したパケットヘッダー変数のリストを、以下で詳しく説明します。IPv6アドレスファミリーを使用している場合のわずかな違いを除いて、これらのフィールドはNTPv3と下位互換性があります。パケットヘッダーフィールドは、送信パケット(接頭辞 x)と受信パケット(接頭辞 r)の両方に適用されます。図8では、デフォルトの32ビットでない場合、いくつかの複数のワードフィールドのサイズがビットで示されています。基本ヘッダーは、パケットの先頭から送信タイムスタンプフィールドの終わりまで拡張されます。

フィールドおよび関連するパケット変数(かっこ内)は、次のように解釈されます。

LI 閏秒インジケータ(leap)：図9で定義されている値で、現在の月の最後の1分間に挿入または削除される予定の閏秒の2ビット整数警告。

```
 +----+-----------------------------+
 | 値 | 意味                        |
 +----+-----------------------------+
 | 0  | 警告なし                    |
 | 1  | 最後の1分が61秒になる       |
 | 2  | 最後の1分が59秒になる       |
 | 3  | 不明 (時刻が同期していない) |
 +----+-----------------------------+

          図9：閏秒インジケータ
```

VN バージョン番号(version)：NTPバージョン番号を表す3ビット整数。現在は4です。

Mode(mode)：モードを表す3ビット整数。図10で定義されている値を使用します。

```
 +----+----------------------------+
 | 値 | 意味                       |
 +----+----------------------------+
 | 0  | 予約                       |
 | 1  | 対称アクティブ             |
 | 2  | 対称パッシブ               |
 | 3  | クライアント               |
 | 4  | サーバー                   |
 | 5  | ブロードキャスト           |
 | 6  | NTP制御メッセージ          |
 | 7  | プライベート利用のため予約 |
 +----+----------------------------+

      図10：アソシエーションモード
```

階層(stratum)：階層を表す8ビット整数。図11で定義されている値を使用します。

```
 +--------+------------------------------------+
 | 値     | 意味                               |
 +--------+------------------------------------+
 | 0      | 未指定または無効                   |
 | 1      | プライマリサーバー (GPS受信機など) |
 | 2-15   | セカンダリサーバー (NTP経由)       |
 | 16     | 同期していない                     |
 | 17-255 | 予約                               |
 +--------+------------------------------------+

               図11：階層パケット
```

受信したパケットの階層値 0 をピア変数`p.stratum`の`MAXSTRAT(16)`にマップし、`MAXSTRAT`以上の`p.stratum`値を送信パケットにマップすることが慣例です。これにより、外部ソースに使用されているのと同じクロック選択アルゴリズムを使用して、通常は階層0に現れる１次参照源を便利に緩和できます(例については[付録A.5.5.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.1)を参照)。

Poll：連続するメッセージ間の最大間隔を表すlog2秒単位の8ビット符号付き整数。最小および最大ポーリング間隔の推奨デフォルト値は、それぞれ6と10です。

精度：システムクロックの精度を表す8ビット符号付き整数(log2秒)。例えば、-18の値は、約1マイクロ秒の精度に対応する。精度は、サービスが最初に起動するときに、システムクロックを読み取るための最小限の反復回数として決定できます。

ルート遅延(rootdelay)：NTPショートフォーマットで、１次参照源までの総往復遅延。

ルート分散(rootdisp)：NTPショートフォーマットで、１次参照源までの分散の合計。

参照ID(refid)：特定のサーバーまたは参照クロックを識別する32ビットのコード。解釈は、階層フィールドの値に依存します。階層0(未指定または無効)の場合、デバッグおよび監視の目的で使用される「キスコード」と呼ばれる4文字のASCII [[RFC1345](https://tools.ietf.org/html/rfc1345)]文字列です。階層1(１次参照源)の場合、これは１次参照源に割り当てられた4オクテット、左詰め、ゼロ詰めのASCII文字列です。参照識別子の正式なリストはIANAによって管理されています。ただし、ASCII文字 "X"で始まる文字列は、登録されていない実験や開発用に予約されています。図12の識別子は、ASCII識別子として使用されています。

```
 +------+---------------------------------------------------------+
 | ID   | 外部参照源                                              |
 +------+---------------------------------------------------------+
 | GOES | 静止実用環境衛星                                        |
 | GPS  | 全地球無線測位システム                                  |
 | GAL  | ガリレオ測位システム                                    |
 | PPS  | 原子時計                                                |
 | IRIG | Inter-Range Instrumentation Group                       |
 | WWVB | 長波標準電波 WWVB Ft. Collins, CO 60 kHz                |
 | DCF  | 長波標準電波 DCF77 Mainflingen, DE 77.5 kHz             |
 | HBG  | 長波標準電波 HBG Prangins, HB 75 kHz                    |
 | MSF  | 長波標準電波 MSF Anthorn, UK 60 kHz                     |
 | JJY  | 長波標準電波 JJY Fukushima, JP 40 kHz, Saga, JP 60 kHz  |
 | LORC | 中波標準電波 LORAN C station, 100 kHz                   |
 | TDF  | 中波標準電波 Allouis, FR 162 kHz                        |
 | CHU  | 短波標準電波 CHU Ottawa, Ontario                        |
 | WWV  | 短波標準電波 WWV Ft. Collins, CO                        |
 | WWVH | 短波標準電波 WWVH Kauai, HI                             |
 | NIST | アメリカ国立標準技術研究所                              |
 | ACTS | アメリカ国立標準技術研究所                              |
 | USNO | アメリカ海軍天文台                                      |
 | PTB  | ドイツ国立理工学研究所                                  |
 +------+---------------------------------------------------------+

                     図12：参照識別子
```

上記の階層1(セカンダリサーバーとクライアント)：これはサーバーの参照識別子であり、タイミングループを検出するために使用できます。IPv4アドレスファミリーを使用する場合、識別子は4オクテットのIPv4アドレスです。IPv6アドレスファミリーを使用する場合は、IPv6アドレスのMD5ハッシュの最初の4オクテットです。NTPv3クライアントを使用するNTPv4サーバーでIPv6アドレスファミリーを使用する場合、[参照ID]フィールドにはランダム値が表示され、タイミングループが検出されないことがあります。

参照タイムスタンプ：NTPタイムスタンプフォーマットで、システムクロックが最後に設定または修正された時刻を表す。

発信タイムスタンプ(org)：NTPタイムスタンプフォーマットで、要求がサーバーから発信されたときのクライアントの時刻を表す。

受信タイムスタンプ(rec)：NTPタイムスタンプフォーマットで、要求がクライアントから到着した時刻を表す。

送信タイムスタンプ(xmt)：NTPタイムスタンプフォーマットで、クライアントに応答されたときのサーバーの時刻を表す。

宛先タイムスタンプ(dst)：NTPタイムスタンプフォーマットで、クライアントからの返信がサーバーから到着した時刻。

注：宛先タイムスタンプフィールドはヘッダーフィールドに含まれていません。パケット到着時に決定され、パケットバッファデータ構造で利用可能になります。

NTPが物理層にアクセスできる場合、タイムスタンプはフレームの開始後にシンボルの先頭に関連付けられます。さもなければ、実装はフレームの最も早いアクセス可能な点にタイムスタンプを関連させようと試みるべきです。

MACはKey Identifierとそれに続くメッセージダイジェストで構成されます。メッセージダイジェストまたは暗号は、[[RFC1321](https://tools.ietf.org/html/rfc1321)]のように、すべてのNTPヘッダーおよびオプションの拡張フィールドで計算されますが、MAC自体は計算されません。

拡張フィールド n：このフィールドのフォーマットについては、[7章5節](four-octet)を参照してください。

鍵識別子(keyid)：シークレット128ビットMD5キーを指定するためにクライアントとサーバーが使用する、32ビットの符号なし整数を表す。

メッセージダイジェスト(digest)：キーに続いてNTPパケットヘッダーフィールドと拡張フィールド(Key IdentifierフィールドまたはMessage Digestフィールドではない)が計算された128ビットのMD5ハッシュ。

ここで使用されるMAC計算は、[[RFC1305](https://tools.ietf.org/html/rfc1305)]と[[RFC4330](https://tools.ietf.org/html/rfc4330)]で定義されたものとは異なるが、既存の実装がMACをどのように生成するかと一貫していることに注意すべきである。

## 7.4. Kiss-o'-Death パケット

階層フィールドが0である場合、それは未指定または無効を意味し、参照IDフィールドを使用して、状態報告およびアクセス制御に有用なメッセージを伝達することができます。これらはKiss-o'-Death(KoD)パケットと呼ばれ、それらが伝えるASCIIメッセージはキスコードと呼ばれます。初期の用途では、クライアントへサーバーアクセス制御に違反するパケットの送信を停止するよう指示するため、KoDパケットと名付けられました。キスコードは、インテリジェントクライアント(NTPv4またはSNTPv4)に役立つ情報を提供します。キスコードは4文字のASCII文字列でエンコードされ、左揃えとゼロ埋めが行われます。文字列は、文字ディスプレイとログファイル用に設計されています。現在定義されているキスコードの一覧を図13に示します。
キスコードの受信者は、キスコードを検査しなければならず、以下の場合には、

a. キスコードが`DENY`または`RSTR`の場合、クライアントはそのサーバーへのアソシエーションをすべて解除し、そのサーバーへのパケットの送信を停止する必要があります。

b. キスコードが`RATE`の場合、クライアントはそのサーバーへのポーリング間隔を直ちに減らし、`RATE`キスコードを受信するたびに引き続き減らなければいけません。

c. ASCII文字 "X"で始まるキスコードは、登録されていない実験や開発用であり、認識されなければ無視しなければいけません(MUST)。

d. 上記の条件以外では、KoDパケットはプロトコルの重要性を持たず、検査後に破棄されます。

```
 +--------+----------------------------------------------------+
 | コード |                           意味                     |
 +--------+----------------------------------------------------+
 | ACST   | アソシエーションがユニキャストサーバーに属する     |
 | AUTH   | サーバー認証に失敗                                 |
 | AUTO   | Autokeyシーケンスが失敗                            |
 | BCST   | アソシエーションがブロードキャストサーバーに属する |
 | CRYP   | 暗号認証または識別に失敗                           |
 | DENY   |リモートサーバーによってアクセス拒否                |
 | DROP   | 対称モードでピアを喪失                             |
 | RSTR   | ローカルポリシーによってアクセス拒否               |
 | INIT   | アソシエーションの初期段階で同期不可               |
 | MCST   | アソシエーションが動的に検出されたサーバーに属する |
 | NKEY   | キーがインストールされていないか、信頼されてない   |
 | RATE   | クライアントがレート閾値を超えたため、サーバーは   |
 |        | 一時的にアクセス拒否                               |
 | RMOT   | ntpdcでリモートホストからのアソシエーションの変更  |
 | STEP   | システム時間のステップ変更が発生したが、           |
 |        | アソシエーションの再同期はまだしていない           |
 +--------+----------------------------------------------------+

                           図13：キスコード
```

受信タイムスタンプと送信タイムスタンプ(サーバーによって設定されます)は、KoDパケットの中では定義されていないため、有効な値として信頼してはならず、破棄しなければいけません(MUST)。

## 7.5. NTP拡張フィールドフォーマット

NTPv4では、1つ以上の拡張フィールドをヘッダーとMACの間に挿入することができ、拡張フィールドが存在するときMACは常に存在します。フィールド書式を定義する以外に、この文書ではフィールドの内容を使用しません。拡張フィールドは、図14に示すフォーマットの要求または応答メッセージで構成されます。

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |       フィールドタイプ        |         フィールド長          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 .                                                               .
 .                        拡張フィールド                         .
 .                                                               .
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                      パディング (必要なら)                    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                 図14：拡張フィールドのフォーマット
```

すべての拡張フィールドは、ワード(4オクテット)の境界でゼロパディングされています。フィールドタイプフィールドは、定義された関数で固有であり、ここで詳述しません。必須フィールドを含む最小のフィールド長は4ワード(16オクテット)ですが、最大フィールド長は既定されていません。フィールド長フィールドは、パディングフィールドを含む拡張フィールド全体の長さをオクテットで示す16ビットの符号なし整数です。

## 8. オン・ワイヤ・プロトコル

NTPオン・ワイヤ・プロトコルの心臓部は、サーバー、ピア、およびクライアント間の時間値を交換するコアメカニズムです。これは本質的にパケットの紛失または重複に耐性があります。データの整合性は、IPチェックサムとUDPチェックサムによって提供されます。フロー制御や再送機能は提供されておらず、必要ありません。このプロトコルでは、パケットヘッダーから抽出されるか、パケットの到着時または発信時にシステムクロックで打ち込まれるタイムスタンプを使用します。タイムスタンプは精度の高いデータであり、リンクレベルの再送信の場合には再送し、送信時にMACを計算する時間に合わせて修正する必要があります。

NTPメッセージは、一般にユニキャストおよびブロードキャストと呼ばれる、1対1および1対多の2つの異なる通信モードを使用します。この文書では、ブロードキャストという用語は、利用可能な1対多のメカニズムとして解釈されます。IPv4の場合、これはIPv4ブロードキャストまたはIPv4マルチキャストのいずれかに相当します。IPv6の場合、これはIPv6マルチキャストに相当します。この目的のために、IANAはIPv4マルチキャストアドレスとして`224.0.1.1` とIPv6マルチキャストアドレスとして末尾`:101`を割り当てました。接頭辞は有効範囲規則で決定されます。これらの割り当てられたマルチキャストアドレスに加えて、他に割り当てられていないマルチキャストアドレスを使用することもできます。

オン・ワイヤ・プロトコルでは、図15に示すように、`t1`から`t4`までの4つのタイムスタンプと3つの状態変数`org`、`rec`、および`xmt`が使用されます。この図は、2つのピアAおよびBのそれぞれが別々にオフセットおよび遅延を測定する最も一般的なケースを示しています。説明のために、パケットのタイムスタンプは小文字で表示され、状態変数は大文字で示されています。状態変数はパケット到着時または出発時のパケットタイムスタンプからコピーされます。

```
             t2            t3           t6            t7
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t1   |   |   t3    |   |    t5   |
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t2   |   |   t4    |   |    t6   | パケット
        +---------+   +---------+   +---------+   +---------+ タイムスタンプ
        |   t1    |   |t3=clock |   |   t5    |   |t7=clock |
        +---------+   +---------+   +---------+   +---------+
        |t2=clock |                 |t6=clock |
        +---------+                 +---------+
                                                               ピア B
        +---------+   +---------+   +---------+   +---------+
   org  |   T1    |   |    T1   |   | t5<>T1? |   |    T5   |
        +---------+   +---------+   +---------+   +---------+
   rec  |   T2    |   |    T2   |   |   T6    |   |    T6   | 状態変数
        +---------+   +---------+   +---------+   +---------+
   xmt  |    0    |   |    T3   |   |  t3=T3? |   |    T7   |
        +---------+   +---------+   +---------+   +---------+

                  t2      t3                 t6          t7
        ---------------------------------------------------------
                 /\         \                 /\            \
                 /           \                /              \
                /             \              /                \
               /               \/           /                 \/
        ---------------------------------------------------------
             t1                t4         t5                  t8

            t1            t4            t5             t8
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t1   |   |   t3    |   |    t5   |
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t2   |   |   t4    |   |    t6   | パケット
        +---------+   +---------+   +---------+   +---------+ タイムスタンプ
        |t1=clock |   |    t3   |   |t5=clock |   |    t7   |
        +---------+   +---------+   +---------+   +---------+
                      |t4=clock |                 |t8=clock |
                      +---------+                 +---------+
                                                               ピア A
        +---------+   +---------+   +---------+   +---------+
   org  |    0    |   |  t3<>0? |   |   T3    |   | t7<>T3? |
        +---------+   +---------+   +---------+   +---------+
   rec  |    0    |   |    T4   |   |   T4    |   |    T8   | 状態変数
        +---------+   +---------+   +---------+   +---------+
   xmt  |   T1    |   |  t1=T1? |   |   T5    |   |  t5=T5? |
        +---------+   +---------+   +---------+   +---------+

                        図15：オン・ワイヤ・プロトコル
```

図では、Aによって送信された最初のパケットには発信タイムスタンプ`t1`のみが含まれ、T1にコピーされます。Bは`t2`でパケットを受信し、`t1`を`T1`にコピーし、受信タイムスタンプ`t2`を`T2`にコピーします。この時点または`t3`の後のある時点で、Bは、`t1`および`t2`と送信タイムスタンプ`t3`を含むパケットをAに送信します。3つのタイムスタンプはすべて、対応する状態変数にコピーされます。Aは、3つのタイムスタンプ`t1`、`t2`、、`t3`および宛先タイムスタンプ`t4`を含むパケットを`t4`で受信します。これら4つのタイムスタンプは、後述の、Aに対するBのオフセットおよび遅延を計算するために使用されます。

`xmt`と`org`の状態変数が更新される前に、重複したパケット、偽のパケット、または再送されたパケットから保護するために、2つの健全性チェックが実行されます。上記の交換では、パケットの送信タイムスタンプ`t3`が`org`状態変数`T3`と一致する場合、パケットは複製または再送されています。パケット内の発信タイムスタンプ`t1`が`xmt`状態変数`T1`と一致しない場合、パケットは偽りです。これらのいずれの場合も、状態変数は更新され、パケットは破棄されます。最後に送信されたパケットの再送を防ぐために、`xmt`状態変数は、偽のチェックに成功した直後にゼロに設定されます。

最新の4つのタイムスタンプ`T1`から`T4`は、Aに対するBのオフセットを計算するために使用されます

```
theta = T(B) - T(A) = 1/2 * [(T2-T1) + (T3-T4)]
```

そして、往復遅延は

```
delta = T(ABA) = (T4-T1) - (T3-T2)
```

です。


カッコ内の数は64ビットの符号なしタイムスタンプから計算され、63の有効ビットに符号を加えた符号付きの値になります。これらの値は、過去68年間から将来の68年間の日付を表すことができます。ただし、オフセットと遅延は、62の有効ビットと2つの符号ビットを含むこれらの値の合計と差として計算されるため、過去34年間から将来の34年間の明白な値を表すことができます。つまり、クライアントの時刻は、サービスが開始される前にサーバーから34年以内に設定する必要があります。これは64ビット整数演算の基本的な制限です。

倍精度浮動小数点演算が利用できる実装では、一次差は倍精度浮動小数に変換され、二次和と差はその算術演算で計算されます。2次項はタイムスタンプの大きさに比べて非常に小さいため、有意性は失われませんが、明確な範囲は34年から68年に戻されます。

クライアントの初期周波数オフセットが比較的大きく、実際の伝播時間が小さい場合には、遅延計算が負になる可能性があります。例えば、周波数差が100ppmであり、間隔`T4-T1`が64秒である場合、見かけの遅延は-6.4msになります。後続の計算では負の値は誤っているので、デルタの値は`s.rho`以上に固定されます。ここで、`s.rho`は[11章1節](https://tools.ietf.org/html/rfc5905#section-11.1)で説明するシステム精度で秒単位です。

上記の議論は、2つの対称ピアがそれらの間のオフセットおよび遅延を独立して測定する最も一般的なケースを前提としています。
ステートレスサーバーの場合、プロトコルを簡素化することができます。
ステートレスサーバーは、`T3`と`T4`をクライアントパケットからサーバーパケットの`T1`と`T2`にコピーし、送信タイムスタンプ`T3`でクライアントに送信します。
残りのプロトコルフィールドを埋めるための追加の詳細は、[9章](https://tools.ietf.org/html/rfc5905#section-9)以降の章と付録に記載されています。

前述のオン・ワイヤ・プロトコルは、サーバー応答パケットの再送に抵抗することに留意してください。ただし、クライアント要求パケットの再送に抵抗することはなく、`T2`および`T3`の新しい値を持つサーバー応答パケットが発生し、誤ったオフセットと遅延が発生します。この脆弱性は、オフセットと遅延を計算した後で`xmt`状態変数をゼロに設定することで回避できます。

## 9. ピアプロセス

以下のプロセスの説明には、関数として実装されるプロセス処理の概要に続く、重要な状態変数のリストが含まれます。付録のスケルトンを頻繁に参照します。スケルトンには、関数をより詳細に記述するためのC言語のフラグメントが含まれています。これには、NTPv4に準拠している実装に必要なパラメータ、変数、および宣言が含まれています。しかし、実際の実装では、多くの追加の変数や関数が必要になることがあります。

ピアプロセスは、サーバまたはピアパケットの到着時に呼び出されます。オン・ワイヤー・プロトコルを実行してクロック・オフセットと往復遅延を判別し、システムおよびポーリング・プロセスで使用される統計を計算します。ピアの変数は、到着するパケットによって構造が初期化され、更新されたときに、関連データ構造内でインスタンス化されます。各サーバーのピアプロセス、ポーリングプロセス、およびアソシエーションプロセスがあります。

## 9.1. ピアプロセス変数

図16、図17、図18、および図19は、一般名、数式名、およびピア変数の簡単な説明をまとめたものです。一般名と数式名は互換性があります。数式名は、この仕様書の式の可読性を高めるためのものです。特に明記しない限り、すべてのピア変数は接頭辞`p`を仮定しています。

```
 +---------+----------+------------------+
 | 一般名  | 数式名   | 説明             |
 +---------+----------+------------------+
 | srcaddr | srcaddr  | 送信元アドレス   |
 | srcport | srcport  | 送信元ポート番号 |
 | dstaddr | dstaddr  | 宛先アドレス     |
 | dstport | destport | 宛先ポート番号   |
 | keyid   | keyid    | 鍵識別子         |
 +---------+----------+------------------+

        図16：ピアプロセスの構成変数
```

```
 +-----------+------------+--------------------+
 | 一般名    | 数式名     | 説明               |
 +-----------+------------+--------------------+
 | leap      | leap       | 閏秒インジケータ   |
 | version   | version    | バージョン番号     |
 | mode      | mode       | モード             |
 | stratum   | stratum    | 階層               |
 | ppoll     | ppoll      | ピアポーリング指数 |
 | rootdelay | delta_r    | ルート遅延         |
 | rootdisp  | epsilon_r  | ルート分散         |
 | refid     | refid      | 参照ID             |
 | reftime   | reftime    | 参照タイムスタンプ |
 +-----------+------------+---------------------+

           図17：ピアプロセスのパケット変数
```
```
 +--------+--------+--------------------+
 | 一般名 | 数式名 | 説明               |
 +--------+--------+--------------------+
 | org    | T1     | 発信タイムスタンプ |
 | rec    | T2     | 受信タイムスタンプ |
 | xmt    | T3     | 送信タイムスタンプ |
 | t      | t      | パケット時刻       |
 +--------+--------+--------------------+

   図18：ピアプロセスのタイムスタンプ変数
```

```
 +--------+---------+--------------------+
 | 一般名 | 数式名  | 説明               |
 +--------+---------+--------------------+
 | offset | theta   | クロックオフセット |
 | delay  | delta   | 往復遅延           |
 | disp   | epsilon | 分散               |
 | jitter | psi     | ジッタ             |
 | filter | filter  | クロックフィルター |
 | tp     | t_p     | フィルター時間     |
 +--------+---------+--------------------+

       図19：ピアプロセスの統計変数
```

以下の設定変数は、設定ファイルによってか、未知のアソシエーションからの最初のパケットが到着し、アソシエーションが確立された場合に初期化されます。

srcaddr：リモートサーバーまたは１次参照源のIPアドレス。 アソシエーションから送信されたパケットの宛先IPアドレスになります。

srcport：サーバーまたは参照クロックのUDPポート番号。 アソシエーションから送信されたパケットの宛先ポート番号になります。対称モード(1と2)で動作する場合、このフィールドにはIANAによって割り当てられたNTPポート番号PORT(123)が設定されている必要があります。他のモードでは、ローカルポリシーに一致する任意の数値を設定することができます。

dstaddr：クライアントのIPアドレス。アソシエーションから送信されたパケットの送信元IPアドレスになります。

keyid：MACの生成と検証に使用される128ビットMD5キーの対称キーID。クライアントとサーバーまたはピアは異なる値を使用できますが、同じキーにマップする必要があります。

各パケットが到着すると、パケットヘッダーの図17で定義された変数が更新されます。それらは、同じ名前のパケット変数と同じ方法で解釈されます。後の処理で、NTPショートフォーマットのパケット値`r.rootdelay`と`r.rootdisp`をピア変数として倍精度浮動小数型に変換すると都合がいいです。

図18で定義されている変数には、8章のオンラインプロトコルによって交換されるタイムスタンプに組み込まれています。変数`t`は、これらの値に関連付けられた秒カウンタ`c.t`です。変数`c.t`は、[12章](https://tools.ietf.org/html/rfc5905#section-12)で説明するクロック調整プロセスによって維持されます。これは、サービス開始後の秒数をカウントしています。図19で定義された変数には、[10章](https://tools.ietf.org/html/rfc5905#section-10)で説明する`clock_filter()`関数によって計算された統計が組み込まれています。変数`tp`は、これらの値に関連付けられた秒カウンタです。

## 9.2. ピアプロセスの処理

受信関数では、パケット到着時のプロセスフローを定義します。例は[付録A.5.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.1)の`receive()`関数に記述されています。アクセス制御には特別な方法は必要ありませんが、実装には広く普及している他の多くのスキームと同様のスキームが含まれることが推奨されます。[付録A.5.4](https://tools.ietf.org/html/rfc5905#appendix-A.5.4)の`access()`関数は、アクセス制御リスト(ACL)を使用してアクセス制限を実装する方法について説明しています。書式チェックでは、フィールドの長さと位置、許容されるバージョン番号(1-4)、正しい拡張フィールドの構文(存在する場合)が必要です。

認証には特別な要件はありません。ただし、認証が実装されている場合は、[[RFC1321](https://tools.ietf.org/html/rfc1321)]で説明されているMD5キー付きハッシュアルゴリズムをサポートする必要があります。

次に、[付録A.5.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.1)の`find_assoc()`関数を例として、送信元アドレスと送信元ポートが一致するアソシエーションテーブルを検索します。図20は、列がパケットモードに対応し、行がアソシエーションモードに対応するディスパッチテーブルである。アソシエーションとパケットモードの共通部分は、以下のステップの1つに処理を割り当てます。

```
 +---------------------------------+---------------------------------------+
 |                                 |             パケットモード            |
 +---------------------------------+-------+-------+-------+-------+-------+
 | アソシエーションモード          |   1   |   2   |   3   |   4   |   5   |
 +---------------------------------+-------+-------+-------+-------+-------+
 | アソシエーションなし          0 | NEWPS | DSCRD | FXMIT | MANY  | NEWBC |
 | 対称アクティブ                1 | PROC  | PROC  | DSCRD | DSCRD | DSCRD |
 | 対称パッシブ                  2 | PROC  | ERR   | DSCRD | DSCRD | DSCRD |
 | クライアント                  3 | DSCRD | DSCRD | DSCRD | PROC  | DSCRD |
 | サーバー                      4 | DSCRD | DSCRD | DSCRD | DSCRD | DSCRD |
 | ブロードキャスト              5 | DSCRD | DSCRD | DSCRD | DSCRD | DSCRD |
 | ブロードキャストクライアント  6 | DSCRD | DSCRD | DSCRD | DSCRD | PROC  |
 +---------------------------------+-------+-------+-------+-------+-------+

                      図20：ピアディスパッチテーブル
```

`DSCRD`：これは、プログラミングエラー、長期遅延パケット、再送パケットにおける、プロトコルの致命的でない違反を示します。 ピアプロセスはパケットを破棄して終了します。

`ERR`：これは、プログラミングエラー、長期遅延パケット、再送パケットにおける、プロトコルの致命的な違反を示します。ピアプロセスはパケットを破棄し、対称パッシブアソシエーションを解除させて終了します。

`FXMIT`：これは、クライアント(モード3)パケットがアソシエーションなし(モード0)と一致しないことを示します。宛先アドレスがブロードキャストアドレスでない場合、サーバーはサーバー(モード4)パケットを構築し、状態を保持せずにクライアントに返し、サーバーパケットヘッダーが構築されます。[付録A.5.3](https://tools.ietf.org/html/rfc5905#appendix-A.5.3)の`fast_xmit()`関数に例が記述されています。パケットヘッダーは、図21に示すように、受信パケットとシステム変数から組み立てられます。システム変数`s.rootdelay`および`s.rootdisp`が倍精度浮動小数に格納されている場合は、最初にNTPショートフォーマットに変換する必要があります。

```
 +-----------------------------------+
 | パケット変数  -->     変数        |
 +-----------------------------------+
 | r.leap        -->     p.leap      |
 | r.mode        -->     p.mode      |
 | r.stratum     -->     p.stratum   |
 | r.poll        -->     p.ppoll     |
 | r.rootdelay   -->     p.rootdelay |
 | r.rootdisp    -->     p.rootdisp  |
 | r.refid       -->     p.refid     |
 | r.reftime     -->     p.reftime   |
 | r.keyid       -->     p.keyid     |
 +-----------------------------------+

       図21：受信パケットヘッダー
```

認証に失敗すると、サーバはcrypto-NAKという特別なメッセージを返します。このメッセージは、図8に示す通常のNTPヘッダーデータで構成されますが、MACは4オクテットの0です。クライアントは、メッセージ内のデータを受け入れるか、拒否します(MAY)。これらのアクションの後、ピアプロセスは終了します。

宛先アドレスがマルチキャストアドレスである場合、送信者はメニーキャストクライアントモードで動作しています。パケットが有効で、サーバーの階層がクライアントの階層よりも小さい場合、サーバーはユニキャスト宛先アドレスを使用して、通常のサーバー(モード4)パケットを送信します。認証が失敗した場合、crypto-NAKは送信されません。これらのアクションの後、ピアプロセスは終了します。

`MANY`：これは、アソシエーションのないサーバー(モード4)パケットを示します。通常、これは以前に送信されたマルチキャストクライアントパケットに対するメニーキャストサーバーの応答の結果としてのみ発生する可能性があります。

パケットが有効である場合、通常のクライアント(モード3)アソシエーションが確立され、アソシエーションが設定ファイルによって確立されたかのように動作が継続する。

`NEWBC`：これは、アソシエーションのないブロードキャスト(モード5)パケットを示します。クライアントは、クライアント(モード3)またはブロードキャストクライアント(モード6)のいずれかのアソシエーションを確立します。例は[付録A.2](https://tools.ietf.org/html/rfc5905#appendix-A.2)の`mobilize()`関すと`clear()`関数で示されています。その後、パケットが検証され、ピア変数が初期化されます。例は[付録A.5.1.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.1.1)の`packet()`関数によって提供されています。

実装が追加のセキュリティ機能または較正機能をサポートしていない場合、アソシエーションモードはブロードキャストクライアント(モード6)に設定され、ピアプロセスは終了します。公開鍵認証をサポートする実装は、Autokeyまたは同等のセキュリティプロトコルを実行することができます(MAY)。実装はアソシエーションモードを3に設定し、短いクライアント/サーバ交換を実行して伝搬遅延を決定すべきです(SHOULD)。交換の後、アソシエーションモードは6に設定され、ピアプロセスはリッスンオンリーモードで継続します。NTPモニターと制御機能のために予約されているモード6パケットと、モード6アソシエーションとの区別に注意してください。

`NEWPS`：これは、アソシエーションのない対称アクティブ(モード1)パケットを示します。クライアントは、対称パッシブ(モード2)アソシエーションを確立します。[付録A.2](https://tools.ietf.org/html/rfc5905#appendix-A.2)の`mobilize()`および`clear()`関数に例が示されています。処理は下記の`PROC`に続きます。

`PROC`：これは、既存のアソシエーションと一致するパケットを示します。パケットのタイムスタンプは、無効、重複、または偽のパケットを避けるために注意深く検査されます。追加の検査が図22に要約されています。crypto-NAKを含むすべてのパケットは、これらの検査に合格した場合にのみ有効と見なされます。

```
   +----------------------+--------------------------------------------------+
   | パケット種別         | 説明                                             |
   +----------------------+--------------------------------------------------+
   | 1 重複パケット       | パケットが古い重複か、最悪の場合、ハッカーによる |
   |                      | 再送です。対称モードでポーリング間隔が不均一な   |
   |                      | 場合に発生する可能性があります。                 |
   | 2 偽パケット         |                                                  |
   | 3 無効               | 1つ以上のタイムスタンプフィールドが無効です。    |
   |                      | 対称モードであるピアが最初のパケットをもう一方の |
   |                      | ピアに送信し、もう一方のピアが最初の応答を受信   |
   |                      | する前に発生する場合があります。                 |
   | 4 アクセス不可       | 送信元がアクセス制御のブラックリストに登録されて |
   |                      | います。                                         |
   | 5 認証失敗           | 暗号メッセージダイジェストがMACと一致しません。  |
   | 6 同期なし           | サーバーが有効な送信元と同期されていません。     |
   | 7 不良ヘッダーデータ | 1つ以上のヘッダーフィールドが無効です。          |
   +----------------------+--------------------------------------------------+

                      図22：パケットエラーチェック
```

処理は、図21に示すように、パケット変数をピア変数に複製することによって継続されます。例は[付録A.5.1.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.1.1)の`packet()`関数に記述されています。`receive()`関数は、図22の検査1-5を実装しています。`packet()`関数は検査6-7を実装しています。エラーが見つかると、パケットは破棄され、ピアプロセスは終了します。

オン・ワイヤ・プロトコルは、[8章](https://tools.ietf.org/html/rfc5905#section-8)で説明したように、最新の4つのタイムスタンプからクロックオフセット`theta` およびラウンドトリップ遅延`delta`を計算します。
基本的には、固定小数点演算のタイムスタンプの差を除いてすべての計算を行うことができますが、一次差分を倍精度浮動小数に変換し、残りの計算をその算術で行うほうがはるかに簡単で、 以下の説明での前提とします。

次に、[13章](https://tools.ietf.org/html/rfc5905#section-13)で説明するポーリングプロセスの8ビットの`p.reach`シフトレジスタを使用して、サーバーが到達可能でデータが最新であるかどうかを判断します。パケットが送信されると、レジスタは1ビット左にシフトされ、右端のビットがゼロに設定されます。有効なパケットが到着すると、右端のビットに1がセットされます。レジスタにゼロ以外のビットが含まれている場合、サーバは到達可能であるとみなされます。そうでない場合は、到達不能とみなされます。最後のパケット以降、ピア・ポーリング間隔が変更された可能性があるため、ホスト・ポーリング間隔が見直されます。[付録A.5.7.2](https://tools.ietf.org/html/rfc5905#appendix-A.5.7.2)の`poll_update()`関数で例を提供します。

分散統計量`epsilon(t)`は、最後のパケットが送信されてからの周波数許容誤差および時間による最大誤差を表します。これは、
秒カウンタに従って`t_0`で測定が行われると初期化されます。

epsilon(t_0) = r.rho + s.rho + PHI * (T4-T1)

ここで、`r.rho`は[7章3節](https://tools.ietf.org/html/rfc5905#section-7.3)で説明するパケット精度であり、`s.rho`は[11章1節](https://tools.ietf.org/html/rfc5905#section-11.1)で説明するシステム精度です(両方とも秒で表されます)。これらの用語は、サーバーとクライアントの両方でシステムクロックを読み取る際の不確実性を説明するために必要となります。

そして、分散は定数`PHI`増加します。すなわち、時刻`t`において、`epsilon(t) = epsilon(t_0) + PHI * (t-t_0)`となります。デフォルト値`PHI = 15ppm`の場合、1日あたり約1.3秒になります。これを理解した上で、引数`t`を省略し、分散は単に`epsilon`と表されます。残りの統計情報は、次の章で説明するクロックフィルターアルゴリズムによって計算されます。

## 10. クロックフィルターアルゴリズム

クロックフィルターアルゴリズムは、ピアプロセスの一部です。それは、正確な時間を表す可能性が最も高いサンプルを選択するために、オン・ワイヤー・データのストリームを処理します。このアルゴリズムは、オフセット(`theta`)、遅延(`delta`)、分散(`epsilon`)、ジッタ(`psi`)、および到着時間(`t`)を含む図19で示す変数を生成します。これらのデータは、緩和アルゴリズムによって使用され、システムクロックを訓練するために使用される最良および最終オフセットを決定します。また、サーバーの状態と、同期に適しているかどうかを判断するためにも使用されます。

クロックフィルターアルゴリズムは、最新のサンプルタプル`(theta, delta, epsilon, t)`を8段シフトレジスタとして機能するフィルター構造体に保存します。タプルは、パケットの到着順に保存されます。ここで、`t`は秒カウンタによるパケット到着時刻であり、ピア変数`tp`と混同しないでください。

以下のスキームを使用して、十分なサンプルがフィルター内にあり、古くなったデータは破棄されるようにします。最初に、すべてのステージのタプルはダミータプル`(0, MAXDISP, MAXDISP, 0)`に設定されます。有効なパケットが到着すると、タプルはフィルターにシフトされ、古いタプルが破棄され、最終的には有効なタプルだけが残ります。

リーチ・レジスタの下位3ビットがゼロ、つまり3回のポーリング間隔で有効なパケットを受信せずに終了したことを示す場合、ポーリングプロセスは、タプルがネットワークから到着したかのように、ダミーのタプルでクロックフィルターアルゴリズムを呼び出します。これが8回のポーリング間隔で継続した場合、レジスタは初期状態に戻ります。

次のステップでは、シフトレジスタのステージが一時的なリストにコピーされ、リストが`delta`の増加によってソートされます。最小の`delta`から始まるステージをインデックス`i`とします。最初のタプル世代`t_0`が最後の有効なサンプル世代`tp`より遅くない場合、関数は現在のピア変数に影響を与えることなく終了します。そうでなければ、`epsilon_i`をi番目のエントリの分散とし、ピア分散`p.disp`とします。

```
                   i=n-1
                   ---     epsilon_i
    epsilon =       \     ----------
                    /        (i+1)
                   ---     2
                   i=0
```

`epsilon`の重複定義に注意してください。クロックフィルターへの入力であろうと出力であろうと、意味は文脈からはっきりしていなければなりません。

観測者は、(a) すべてのステージが分散`MAXDISP`のダミータプルで構成されている場合、計算される分散はわずか16秒未満であり、(b) 有効なタプルがレジスタにシフトされるたびに、有効なタプルの分散に応じて、分散が半分に低下し、(c)4つ目の有効パケットの後、分散は、ピア変数が許容可能かどうかを決定するための選択アルゴリズムによって使用される`MAXDIST`パラメータの仮定値である1秒より少し小さくなることに注意してください。

ソートされたリストの最初のステージのオフセットを`theta_0`とします。任意の順序の他のステージでは、ジッタはRMS平均

```
                        +-----                 -----+^1/2
                        |  n-1                      |
                        |  ---                      |
                1       |  \                     2  |
    psi   =  -------- * |  /    (theta_0-theta_j)   |
              (n-1)     |  ---                      |
                        |  j=1                      |
                        +-----                 -----+

```

であり、`n`はフィルター内の有効なタプル数`(n> 1)`です。一貫性を保証し、他の計算での除算例外を回避するため、`psi`は秒単位で表されるシステム精度`s.rho`を下限として境界付けられます。サーバー品質のランク付けの主な要因とは一般的には考えられていませんが、ジッタは基本的なタイムキーピング性能とネットワークの輻輳状態を示す重要な指標です。緩和アルゴリズムに特に重要なのは、遅延と分散から計算されるピア同期距離です。

```
 lambda = (delta / 2) + epsilon
```

`epsilon`と`lambda`は割合`PHI`で増加することに注意してください。 `lambda`はそれぞれ使用時に再計算されるため、`lambda`は状態変数ではありません。 これは、各サーバーから利用可能な時間の品質を評価するためのメトリックとして、緩和アルゴリズムによって使用されるルート同期距離の構成要素です。

NTPv3とは異なり、階層を16に設定してインジケータを3に設定すると、NTPv4のアソシエーションにタイムアウト条件が表示されないことに注意することが重要です。アソシエーション変数は、最後のパケットが到着したときに決定された値を保持します。NTPv4では`lambda`が時間とともに増加するため、最終的に同期距離は距離閾値`MAXDIST`を超えます。この場合、アソシエーションは同期には不適切とみなされます。

[付録A.5.2](https://tools.ietf.org/html/rfc5905#appendix-A.5.2)の`clock_filter()`関数には、クロックフィルターアルゴリズムの実装例が示されています。

## 11. システムプロセス

それぞれ新規サンプル(`theta`, `delta`, `epsilon`, `jitter`, `t`)がクロックフィルターアルゴリズムによって生成されると、システムプロセスにおける選択、クラスタ、結合、およびクロック制御アルゴリズムからなる緩和アルゴリズムによってすべてのピアプロセスが走査されます。選択アルゴリズムはすべてのアソシエーションを走査し、明らかに時間が不正確な `falsetickers` を除外し、`truechimers` を残します。一連のラウンドで、クラスタアルゴリズムは、指定された最小数の生存者が残るまで、重心から統計的に最も離れたアソシエーションを破棄します。結合アルゴリズムは、加重平均ベースで最良かつ最終の統計を生成します。最終的なオフセットは、システムクロックを正しい時間に導くためにクロック規律アルゴリズムに渡されます。

クラスタアルゴリズムは、生存者の1つをシステムピアとして選択します。関連する統計(`theta`, `delta`, `epsilon`, `jitter`, `t`)は、従属サーバーおよびクライアントによって継承され、同じマシン上で実行されている他のアプリケーションで使用可能なシステム変数を構築するために使用されます。

## 11.1. システムプロセス変数

図23は、一般名、数式名、および各システム変数の簡単な説明をまとめたものです。特に記載がない限り、すべての変数は接頭辞`s`を前提としています。

```
 +-----------+---------+--------------------------+
 | 一般名    | 数式名  | 説明                     |
 +-----------+---------+--------------------------+
 | t         | t       | 更新時刻                 |
 | p         | p       | システムピアインジケータ |
 | leap      | leap    | 閏秒インジケータ         |
 | stratum   | stratum | 階層                     |
 | precision | rho     | 精度                     |
 | offset    | THETA   | 結合オフセット           |
 | jitter    | PSI     | 結合ジッタ               |
 | rootdelay | DELTA   | ルート遅延               |
 | rootdisp  | EPSILON | ルート分散               |
 | v         | v       | 生存者リスト             |
 | refid     | refid   | 参照ID                   |
 | reftime   | reftime | 参照時間                 |
 | NMIN      | 3       | 最小生存者数             |
 | CMIN      | 1       | 最小候補者数             |
 +-----------+---------+--------------------------+

             図23：システムプロセス変数
```

`t`、`p`、`offset`、および`jitter`変数と`NMIN`および`CMIN`定数を除いて、変数は同名の同等変数と同じフォーマットと解釈を持ちます。 `NMIN`パラメータと`CMIN`パラメータは、次章で説明する選択アルゴリズムとクラスタアルゴリズムで使用されます。

変数`t`は、最後の更新時刻の秒カウンタです。[付録A.5.5.4](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.4)の`clock_update()`関数に例を示します。
変数`p`は、[11章2節2項](https://tools.ietf.org/html/rfc5905#section-11.2.2)の`cluster()`関数によって決定されるシステムピア識別子です。
変数`precision`は、同名のパケット変数と同じ形式です。
`precision`は、log2単位で、クロックを読み取るための分解能と時間のうち大きい方と定義されます。
例えば、60Hzで増分するメイン周波数クロックの精度は、システムクロックハードウェアの表示がナノ秒になっても16msです。

`offset`および`jitter`変数は、[11章2節3項](https://tools.ietf.org/html/rfc5905#section-11.2.3)の結合アルゴリズムによって決定されます。これらの値は、システムクロックを制御するために使用される最良および最終のオフセットとジッタを表します。

最初に、すべての変数はゼロにクリアされ、次に`leap`は3(非同期)に設定され、階層は`MAXSTRAT(16)`に設定されます。`MAXSTRAT`は、送信パケットのゼロにマップされることに注意してください。

## 11.2. システムプロセスの動作

図24は、クロック選択処理によって実行されるシステムプロセスの動作をまとめたものです。[11章2節1項](https://tools.ietf.org/html/rfc5905#section-11.2.1)で説明される選択アルゴリズムは、合意の原則に基づいて推測された正しい候補(truechimers)の多数決を生成します。[11章2節2項](https://tools.ietf.org/html/rfc5905#section-11.2.2)で説明されるクラスタアルゴリズムは、最も正確な生存者を生成するために異常値を破棄します。[11章2節3項](https://tools.ietf.org/html/rfc5905#section-11.2.3)で説明される結合アルゴリズムは、クロック規律アルゴリズムのための最良の最終的なオフセットを提供します。例は[付録A.5.5.6](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.6)で説明されています。選択アルゴリズムが過半数のグループを生成できない場合、または少なくとも`CMIN`の生存者を生成できない場合、システムプロセスはシステムクロックを訓練することなく終了します。成功すると、クラスタアルゴリズムは統計的に最良の候補をシステムピアとして選択し、その変数はシステム変数として継承されます。

```
                        +-----------------+
                        | clock_select()  |
                        +-----------------+
 ................................|...........
 .                               V          .
 .      yes +---------+ +-----------------+ .
 .       +--|  容認?  | | 走査候補        | .
 .       |  +---------+ |                 | .
 .       V        no |  |                 | .
 .  +---------+      |  |                 | .
 .  | ピア追加|      |  |                 | .
 .  +----------      |  |                 | .
 .       |           V  |                 | .
 .       +---------->-->|                 | .
 .                      |                 | .
 . 選択アルゴリズム     +-----------------+ .
 .................................|..........
                                  V
                     no +-------------------+
          +-------------|      生存者?      |
          |             +-------------------+
          |                       | yes
          |                       V
          |             +-------------------+
          |             |      クラスタ     |
          |             |    アルゴリズム   |
          |             +-------------------+
          |                       |
          |                       V
          V         yes +-------------------+
          |<------------|     n < CMIN?     |
          |             +-------------------+
          V                       |
   +-----------------+            V no
   |   s.p = NULL    |  +-------------------+
   +-----------------+  |   s.p = v_0.p     |
          |             +-------------------+
          V                       |
   +-----------------+            V
   | return (UNSYNC) |  +-------------------+
   +-----------------+  |   return (SYNC)   |
                        +-------------------+

                    図24：クロック選択処理
```

## 11.2.1. 選択アルゴリズム

選択アルゴリズムとクラスタアルゴリズムは別々に記述されていますが、スケルトンコードで結合されています。選択アルゴリズムは、当初 Marzullo [[ref6](https://tools.ietf.org/html/rfc5905#ref-ref6)]によって提案されたビザンチン合意の原則を使用して、正確性を向上させるために修正された、truechimers の多数派で構成される交点間隔を見つけるように動作します。アルゴリズムの概要を[付録A.5.5.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.1)のc`lock_select()`関数の前半で説明します。

まず、[付録A.5.5.3](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.3)の`accept()`関数に示されているように、プロトコルのルールに従って使用できないサーバが検出され、破棄されます。次に、残りの候補に対して1組の`(p, type, edge)`が生成されます。ここで、`p`はアソシエーション識別子であり、`type`はその候補の`theta`を中心とする正確度区間の上位(`+1`)、中位(`0`)、および下位(`-1`)の端点を識別します。これにより、下限`(p, -1, theta - lambda)`、中間点`(p, 0, theta)`、および上限`(p, +1, theta + lambda)`の3つのタプルが得られます。この計算の例は、[付録A.5.1.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.1.1)の`rootdist()`関数によって示されています。アルゴリズムの手順は次のとおりです。

1.　`m`個のアソシエーションのそれぞれについて、上で定義したような3つのタプルを候補リストに配置します。

2.　リストのタプルを要素`edge`でソートします。これらの間隔の下限、中間点、上限を最低から最高まで順番に並べます。falsetickersの数を`f = 0`に設定します。

3.　中間点の数を`d = 0`に設定します。`c = 0`に設定します。最低点から最高点まで走査します。`c`に対して下限ごとに1を加算し、上限ごとに1を減算し、`d`に対して中間点ごとに1を加算します。`c > = m - f`の場合、終了します。 `l = 現在の下限`に設定します。

4.　`c = 0`に設定します。最高点から最低点まで走査します。`c`に対して上限ごとに1を加算し、下限ごとに1を減算し、`d`に対して中間点ごとに1を加算します。 `c > = m - f`の場合、終了します。 `u = 現在の上限`に設定します。

5.　`d = f`であり、`l < u`であるか？はいの場合は、手順5Aに進みます。それ以外の場合は、手順5Bを実行します。

5A.　成功：交点間隔は`[l、u]`です。

5B.　`f`に1を加えます。 `f <(m / 2)`か？ はいの場合は、手順3に戻ります。いいえの場合は、手順6に進みます。

6.　失敗。 過半数のグループが見つかりませんでした。システムクロックを訓練するのに適した候補はありません。


アルゴリズムは、[付録A.5.5.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.1)で詳しく説明されています。falsetickers`(f = 0)`が存在せず、すべての正しいサーバの中間点、すなわちtruechimerを含む空でない交差区間を見つけることを試みるという前提から始まることに注意してください。空ではない区間が見つからない場合は、想定されるfalsetickersの数を1つ増やして再度試行します。空ではない間隔が見つけられ、falsetickersの数がtruechimerの数よりも少ない場合、多数派のグループが発見され、各truechimer(`theta`)の中間点は、クラスタアルゴリズムで利用可能な候補を表します。

過半数のグループが見つからない場合、またはtruechimerの数が`CMIN`より少ない場合は、システムクロックを訓練する候補が不十分です。`CMIN`は、正確性の要件と一致するサーバーの最小数を定義します。疑い深いオペレータは`CMIN`を設定し、複数の冗長サーバーを使用してアルゴリズムが適切に緩和されるようにできます。しかし、歴史的な理由から、`CMIN`のデフォルト値は`1`です。

## 11.2.2. クラスタアルゴリズム

過半数のグループの候補は、タプル`(p, theta_p, psi_p, lambda_p)`の形で生存者リスト`v`に格納されます。ここで、`p`はアソシエーション識別子であり、`theta_p`、`psi_p`、`stratum_p`はそれぞれ、アソシエーション`p`のオフセット、ジッタ、階層であり、`lambda_p`は`stratum_p * MAXDIST + lambda`に等しいメリットファクタであり、`lambda`はアソシエーション`p`のルート同期距離です。このリストは、以下のクラスタアルゴリズムによって処理されます。例は、[付録A.5.5.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.1)の`clock_select()`関数の後半で示されています。

1.　`(p, theta_p, psi_p, lambda_p)`が生存者の候補を表すものとします。

2.　`lambda_p`を増やして候補をソートします。`n`を候補者の数とし、`NMIN`を最低必要数の生存者とします。

3.　候補ごとに、選択ジッタ`psi_s`を計算します。

```
           +-----                       -----+^1/2
           |        n-1                      |
           |        ---                      |
           |   1    \                     2  |
   psi_s = | ---- * /  (theta_s - theta_j)   |
           |  n-1   ---                      |
           |        j=1                      |
           +-----                       -----+
```

4.　`psi_s`が最大の候補`psi_max`として選択します。

5.　`psi_p`が最小の候補を`psi_min`として選択します。

6.　`psi_max < psi_min`または`n <= NMIN`か？はいの場合は、ステップ6Aに進みます。それ以外の場合は、ステップ6Bに進みます。

6A.　完了。生存者リストの残りの候補者は、優先順位の順にランク付けされます。リストの最初のエントリはシステムピアを表します。その変数は後でシステム変数を更新するために使用されます。

6B.　`psi_max`を異常値候補として除外します。`n`を1減らして手順3に戻ります。

このアルゴリズムは一連のラウンドで動作し、各ラウンドで最大選択ジッタ`psi_s`を持つ統計的な外れ値を破棄します。ただし、`psi_s`が最小ピアジッタ`psi_p`よりも小さい場合は、外れ値を破棄しても改善できません。上記および生存者の最小数は、アルゴリズムの終了条件を表します。終了時に、`psi_max`の最終値は、後で使用するためのシステム選択ジッタ`PSI_s`として保存されます。

## 11.2.3. 結合アルゴリズム

クロック結合経路は、残りの生存者を処理して、クロック規律アルゴリズムのための最良かつ最終的なデータを生成します。
この処理では、ピアオフセットおよびジッタ統計を処理して、結合システムオフセット`THETA`およびシステムピアジッタ`PSI_p`を生成します。ここで、各サーバ統計は、ルート同期距離の逆数によって重み付けされ、結果は正規化されます。[付録A.5.5.5](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.5)の`clock_combine()`関数に例を示します。

結合された`THETA`はクロック更新ルーチンに渡されます。生存者リストの最初の候補は、識別子`p`を持つシステムピアとして指名されます。システムピアジッタ`PSI_p`は、システムジッタ`PSI`の構成要素です。これは、選択ジッタ`PSI_s`とともに使用され、システムジッタを生成します。

```
 PSI = [(PSI_s)^2 + (PSI_p)^2]^1/2
```

システムピアから更新が受信されるたびに、時刻更新関数が呼び出されます。ルールによって、到着時刻`p.t`が、使用された最後の更新よりも厳密に遅くない場合、更新は破棄されます。`IGNOR`、`PANIC`、`ADJ`、および`STEP`というラベルは、次章で説明するローカルクロックルーチンからのリターンコードを参照しています。

`IGNORE`は、更新が外れ値として無視されたことを意味します。`PANIC`は、オフセットがパニック閾値`PANICT(1000s)`よりも大きいことを意味し、システムログへの診断メッセージとともにプログラムを終了させるべきです(SHOULD)。`STEP`は、オフセットがパニック閾値よりも小さいが、ステップ閾値`STEPT(125ms)`よりも大きいことを意味します。この場合、クロックは正しいオフセットにステップされますが、これはすべてのピアデータが無効になったことを意味するため、すべてのアソシエーションをリセットしなければならず、クライアントは最初の開始時に開始しなければなりません。

`ADJ`は、オフセットがステップの閾値より小さく、したがって有効な更新を意味します。この場合、図25に示すように、システム変数はピア変数から更新されます。

```
 +-------------------------------------------+
 | システム変数 <-- システムピア変数         |
 +-------------------------------------------+
 | s.leap      <-- p.leap                    |
 | s.stratum   <-- p.stratum + 1             |
 | s.offset    <-- THETA                     |
 | s.jitter    <-- PSI                       |
 | s.rootdelay <-- p.delta_r + delta         |
 | s.rootdisp  <-- p.epsilon_r + p.epsilon + |
 |                 p.psi + PHI * (s.t - p.t) |
 |                 + |THETA|                 |
 | s.refid     <-- p.refid                   |
 | s.reftime   <-- p.reftime                 |
 | s.t         <-- p.t                       |
 +-------------------------------------------+

          図25：システム変数の更新
```

ここに示されていない重要な詳細があります。分散増分`(p.epsilon + p.psi + PHI * (s.t - p.t) + |THETA|)`は、`MINDISP`によって下限付けられています。非常に高速なプロセッサとネットワークと非常に小さい遅延と分散を持つサブネットでは、同じ階層で動作するピア間のループを回避する`s.rootdisp(EPSILON)`が単調増加します。

システム変数は、従属アプリケーションプログラムが公称性能統計として使用できます。システムオフセット`THETA`は、使用可能な同期ソースに対するクロックオフセットです。システムジッタ`PSI`は、この値を決定する際の誤差の推定値であり、期待誤差と呼ばれます。ルート遅延`DELTA`は、一時参照源に対する総往復遅延です。最後に、ルート同期距離は次のように定義されます。

```
 LAMBDA = EPSILON + DELTA / 2
```

すべての原因による最大誤差を表し、ルート同期距離と呼ばれる。

[付録A.5.5.4](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.4)にクロック更新処理の例を示します。

## 11.3. クロック規律アルゴリズム

NTPv4クロック規律アルゴリズムは、2つの非常に異なる設計思想によるフィードバック制御システムの組み合わせとして機能する以下の規律に短縮されます。位相同期ループ(PLL)設計では、更新間隔`mu`秒の周期的な位相更新を直接使用して時間誤差を最小限に抑え、間接的に周波数誤差を最小限に抑えます。周波数ロックループ(FLL)設計では、間隔`mu`での周期的な周波数更新を直接使用して周波数誤差を最小限に抑え、間接的に時間誤差を最小にします。[[ref7](https://tools.ietf.org/html/rfc5905#ref-ref7)]に示されているように、PLLは通常、ネットワーク・ジッタが支配的な場合にはより良く動作しますが、FLLはオシレータ・ワンダーが支配的になるとうまく動作します。この章では、NTPv4における設計の仕組みの概要について説明します。設計原理の詳細な説明は、[[ref7](https://tools.ietf.org/html/rfc5905#ref-ref7)]に掲載されています。これには、パフォーマンス分析も含まれています。

この規律は、図26に示すフィードバック制御システムとして実装されています。変数`theta_r`は結合アルゴリズムのオフセット(基準位相)を、`theta_c`はVFOオフセット(制御フェーズ)を表します。各更新は、瞬間位相差`theta_r - theta_c`を表す信号`V_d`を生成します。各サーバのクロックフィルターは、タップ付き遅延ラインとして機能し、クロックフィルターアルゴリズムによって選択されたタップで出力が取得されます。選択アルゴリズム、クラスタアルゴリズム、および結合アルゴリズムは、複数のフィルターからのデータを結合して信号`V_s`を生成します。インパルス応答`F(t)`を有するループフィルターは、信号`V_c`を生成し、VFO周波数`omega_c`を制御し、したがってループを閉じる位相`theta_c`の積分を制御します。信号`V_c`は、[12章](https://tools.ietf.org/html/rfc5905#section-12)のクロック調整プロセスによって生成されます。これらの関数を実装する詳細な方程式は、[付録A.5.5.6](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.6)および[付録A.5.6.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.6.1)の処理に最もよく示されています。

```
      theta_r + +----------\        +--------------------+
  NTP --------->|           \  V_d  |                    | V_s
      theta_c - | 位相検出器 ------>| クロックフィルター |----+
      +-------->|           /       |                    |    |
      |         +----------/        +--------------------+    |
      |                                                       |
    -----                                                     |
   /     \                                                    |
   | VFO |                                                    |
   \     /                                                    |
    -----    ........................................         |
      ^      .          ループフィルター            .         |
      |      . +----------+   x  +-------------+    .         |
      | V_c  . |          |<-----|             |    .         |
      +------.-| クロック |   y  | 位相/周波数 |<-------------+
             . | 調整     |<-----| 予測        |    .
             . |          |      |             |    .
             . +----------+      +-------------+    .
             ........................................

        図26：クロック規律フィードバックループ
```

通常、上記の擬似線形フィードバックループは、システムクロックを制御するように動作します。しかしながら、非線形アルゴリズムが著しい改善をもたらすケースもあります。
1つのケースは、本質的なクロック周波数の知識なしに規律が始まるときです。擬似線形ループは、正確な測定値を測定するのに数時間を要し、その時間の大部分の間、ポーリング間隔を長くすることはできません。以下に説明する非線形ループは、15分でこれを行います。もう1つのケースは、混雑したネットワークリンクのために時々大きなジッタのバーストが存在する場合です。以下に説明するステートマシンは、15分間未満のエラーバーストに耐えます。

図27に、変数(小文字)またはパラメータ(大文字)名、数式名、および短い説明を含む変数とパラメータの概要を示します。別段の記載がない限り、すべての変数は接頭辞`c`を前提としています。変数`t`、`tc`、`state`、`hyster`、および`count`は整数です。 残りの変数は倍精度浮動小数点です。それぞれの機能は以下のアルゴリズムの説明で解説します。

```
 +--------+---------+--------------------------+
 | 一般名 | 数式名  | 説明                     |
 +--------+---------+--------------------------+
 | t      | timer   | 秒カウンタ               |
 | offset | theta   | 結合オフセット           |
 | resid  | theta_r | 残留オフセット           |
 | freq   | phi     | クロック周波数           |
 | jitter | psi     | クロックオフセットジッタ |
 | wander | omega   | クロック周波数ワンダ     |
 | tc     | tau     | 時定数 (log2)            |
 | state  | state   | 状態                     |
 | adj    | adj     | 周波数調整               |
 | hyster | hyster  | ヒステリシスカウンタ     |
 | STEPT  | 125     | ステップ閾値(.125秒)     |
 | WATCH  | 900     | ステップアウト閾値(秒)   |
 | PANICT | 1000    | パニック閾値 (1000秒)    |
 | LIMIT  | 30      | ヒステリシス上限値       |
 | PGATE  | 4       | ヒステリシスゲート       |
 | TC     | 16      | 時定数スケール           |
 | AVG    | 8       | 平均化定数               |
 +--------+---------+--------------------------+

       図27：クロック規律変数とパラメータ
```

オフセットがパニック閾値`PANICT(1000秒)`より大きい場合、プロセスは直ちに終了します。
状態遷移関数は[付録A.5.5.7](https://tools.ietf.org/html/rfc5905#appendix-A.5.5.7)の`rstclock()`関数で記述されています。
図28に、この関数で使用される状態遷移関数を示します。これには4つの列があり、それぞれ、状態名、オフセット`theta`がステップ閾値よりも小さい場合の遷移先と動作、それ以外の場合の遷移先と動作、最後にいくつかのコメントを示します。

```
 +-------+---------------------+--------------------+--------------+
 | 状態  | theta < STEP        | theta > STEP      | コメント      |
 +-------+---------------------+--------------------+--------------+
 | NSET  | ->FREQ              | ->FREQ             | 周波数       |
 |       | 時刻調整            | 時刻ステップ調整   | ファイルなし |
 +-------+---------------------+--------------------+--------------+
 | FSET  | ->SYNC              | ->SYNC             | 周波数       |
 |       | 時刻調整            | 時刻ステップ調整   | ファイルあり |
 +-------+---------------------+--------------------+--------------+
 | SPIK  | ->SYNC              | if < 900 s ->SPIK  | 外れ値検出   |
 |       | 周波数調整          | else ->SYNC        |              |
 |       | 時刻調整            | 周波数ステップ調整 |              |
 |       |                     | 時刻ステップ調整   |              |
 +-------+---------------------+--------------------+--------------+
 | FREQ  | if < 900 s ->FREQ   | if < 900 s ->FREQ  | 初期周波数   |
 |       | else ->SYNC         | else ->SYNC        |              |
 |       | 周波数ステップ調整  | 周波数ステップ調整 |              |
 |       | 時刻調整            | 時刻調整           |              |
 +-------+---------------------+--------------------+--------------+
 | SYNC  | ->SYNC              | if < 900 s ->SPIK  | 通常動作     |
 |       | 周波数調整          | else ->SYNC        |              |
 |       | 時刻調整            | 周波数ステップ調整 |              |
 |       |                     | 時刻ステップ調整   |              |
 +-------+---------------------+--------------------+--------------+

                           図28：状態遷移関数
```

テーブルのエントリでは、次の状態は矢印`->`で示されます。時間の調整や周波数の調整などのアクションは、`local_clock()`関数の`PLL/FLL`フィードバックループによって実装されます。ステップクロック動作はクロックを直接設定することで実現されますが、これはオフセットがステップ閾値`STEPT(0.125s)`を超えた時、ステップアウト閾値`WATCH(900s)`の後に実行されます。これは、極端なネットワーク輻輳の条件下でのクロックステップに抵抗します。

ジッタ(`psi`)およびワンダ(`omega`)の統計値は、重み係数`AVG`を用いた指数平均を使用して計算されます。時定数指数(`tau`)は、`psi`と現在のオフセット`theta`の大きさを比較することによって決定されます。オフセットがクロックジッタの`PGATE(4)`倍より大きい場合、ヒステリシスカウンタのヒステリシスは`2`減少します。それ以外の場合は、`1`だけ増加します。ヒステリシスが上限値`LIMIT(30)`まで増加すると、`tau`が`1`増えます。 下限値`-LIMIT(-30)`まで減少すると、`tau`が`1`減少します。通常、`tau`は`MAXPOLL`の近くを前後しますが、温度スパイクが周波数の急上昇を引き起こすと急速に減少します。

## 12. クロック調整プロセス

実際のクロック調整プロセスは、周波数補正と残りのオフセット`theta_r`の固定割合を加算するために1秒間隔で実行されます。`theta_r`は、事実上、各更新時にループフィルタによって生成される`theta`値の指数関数的減衰です。`TC`パラメータは、利便性のためにポーリング間隔に一致するように時定数を調整します。分散`EPSILON`は1秒ごとに`PHI`だけ増加することに注意してください。

クロック調整プロセスには、秒カウンタ`c.t`を駆動するタイマ割込み機構が組み込まれています。サービスが開始されるとゼロから始まり、毎秒1回インクリメントします。各割込みで`clock_adjust()`関数が呼び出され、クロック規律のクロック周波数の調整が組み込まれ、次に、秒のカウンタが次章で定義されている状態変数`p.next`と等しいかそれを超えるかどうかが判定されます。もしそうなら、ポーリングプロセスが呼び出されてパケットを送信し、次の`p.next`値を計算します。

クロック調整プロセスの例は、[付録A.5.6.1](https://tools.ietf.org/html/rfc5905#appendix-A.5.6.1)の`clock_adjust()`関数で示されています。

## 13. ポーリングプロセス

各アソシエーションは、一定間隔で実行されるポーリングプロセスをサポートし、対称、クライアント、およびブロードキャストのサーバーアソシエーションでパケットを構築して送信します。これは、クロックフィルタと到達レジスタを管理するためにサーバが到達可能であるかどうかに関わらず、連続して実行されます。

##13.1. ポーリングプロセス変数

図29は、一般名、数式名、およびポーリングプロセス変数(小文字)とパラメータ(大文字)の簡単な説明をまとめたものです。別段の記載がない限り、すべての変数は接頭辞`p`を仮定しています。

```
 +---------+---------+----------------------+
 | 一般名  | 数式名  | 説明                 |
 +---------+---------+----------------------+
 | hpoll   | hpoll   | ホストポーリング指数 |
 | last    | last    | 最後のポーリング時間 |
 | next    | next    | 次のポーリング時間   |
 | reach   | reach   | 到達レジスタ         |
 | unreach | unreach | 未達カウンター       |
 | UNREACH | 24      | 到達不能限界         |
 | BCOUNT  | 8       | バーストカウント     |
 | BURST   | flag    | バースト許可         |
 | IBURST  | flag    | iburst許可           |
 +---------+---------+----------------------+

   図29：ポーリングプロセスの変数とパラメータ
```

ポーリングプロセス変数は、ピアプロセス変数とともにアソシエーションデータ構造内に割り当てられる。以下は、変数の詳細な説明です。パラメータは次のテキストで呼び出されます。

`hpoll`：ポーリング指数を表す符号付き整数(log2秒)

`last`：最新のパケットが送信された秒数を表す整数

`next`：次のパケットが送信される秒数を表す整数

`reach`：ピアおよびポーリングプロセスで共有される8ビット整数シフトレジスタ

`unreach`：サーバーが到達不能になった秒数を表す整数

## 13.2. ポーリングプロセスの動作

前で説明したように、毎秒1回、クロック調整プロセスが呼び出されます。この処理は、各アソシエーションについてポーリング処理を順番に呼び出します。次のポーリングメッセージの時間が秒カウンタより大きい場合、関数は直ちに復帰します。対称(mode 1,2)、クライアント(mode 3)、およびブロードキャストサーバー(mode 5)のアソシエーションは、通常、パケットを送信します。ブロードキャストクライアント(mode 6)のアソシエーションは、`reach`変数と到達不能変数を更新するために関数を実行しますが、パケットは送信しません。ポーリングプロセスは、パケットを送信するために送信プロセスを呼び出します。バースト(`barst > 0`)の場合は、ポーリング更新処理を呼び出して次のポーリング間隔を設定する以外はこれ以上実行されません。

バーストでない場合、`reach`変数は1ビット左にシフトされ、ゼロを置き換えて最右ビットが置き換えられます。最後の3つのポーリング間隔でサーバがリッスンされていない場合、クロックフィルタ処理が呼び出されて分散が増加します。例を[付録A.5.7.3](https://tools.ietf.org/html/rfc5905#appendix-A.5.6.1)に示します。

`BURST`フラグが立ち、サーバーが到達可能で、有効な同期元が使用可能な場合、クライアントは各ポーリング間隔で`BCOUNT(8)`パケットのバーストを送信します。バースト内のパケット間の間隔は2秒です。これは、長いポーリング間隔でジッタを正確に測定するのに便利です。`IBURST`フラグが立ちし、これがサーバーに到達できないときに送信された最初のパケットである場合、クライアントはバーストを送信します。これは、距離の閾値以下の同期距離を素早く減らし、クロックを同期させるのに役立ちます。

`P_MANY`フラグがアソシエーションの`p.flags`ワードで立っている場合、これはメニーキャストクライアントのアソシエーションです。メニーキャストクライアントアソシエーションは、`MINPOLL`間隔でクライアントモードのパケットを指定されたマルチキャストグループアドレスに送信します。このアソシエーションは`TTL 1`で開始されます。次回のポーリングの時までに、`MINCLOCK`サーバーが確立されていない場合、ttlは1つ増えます。`MINCLOCK`サーバを見つけることなく、ttlが限界値`TTLMAX`に達すると、ポーリング間隔は`BEACON`に達するまで増加し、最初から開始されます。

`poll()`関数には、サーバーが到達不能になった場合にポーリング間隔を戻す機能が組み込まれています。`reach`がゼロ以外の場合、サーバーは到達可能であり、`unreach`はゼロに設定されています。 さもなければ、`unreach`は最大の`UNREACH`へのポーリングごとに1ずつ増分されます。その後、各ポーリング`hpoll`は1だけ増加し、ポーリング間隔を`poll_update()`関数によって決定される最大`MAXPOLL`まで2倍にします。サーバーが再び到達可能になると、`unreach`はゼロに設定され、`hpoll`はシステム変数`tc`にリセットされ、操作は正常に再開します。

送信プロセスによってパケットが送信されます。一部のヘッダー値は、以前のパケットによって残されたピア変数からコピーされ、他のヘッダー値はシステム変数からコピーされます。図30は、どの値が各ヘッダーフィールドにコピーされるかを示しています。これらの実装では、ルート遅延とルート分散に倍精度浮動小数点型を使用するため、これらをNTPショートフォーマットに変換する必要があります。他のすべてのフィールドは、ピアとシステム変数からそのままコピーされるか、システムクロックからタイムスタンプとして取り込まれます。

```
 +--------------------------------+
 | パケット変数  <--  変数        |
 +--------------------------------+
 | x.leap        <--  s.leap      |
 | x.version     <--  s.version   |
 | x.mode        <--  s.mode      |
 | x.stratum     <--  s.stratum   |
 | x.poll        <--  s.poll      |
 | x.precision   <--  s.precision |
 | x.rootdelay   <--  s.rootdelay |
 | x.rootdisp    <--  s.rootdisp  |
 | x.refid       <--  s.refid     |
 | x.reftime     <--  s.reftime   |
 | x.org         <--  p.xmt       |
 | x.rec         <--  p.dst       |
 | x.xmt         <--  clock       |
 | x.keyid       <--  p.keyid     |
 | x.digest      <--  md5 digest  |
 +--------------------------------+

   図30：xmit_packetパケットヘッダー
```

ポーリング更新処理は、有効なパケットが受信されたとき、およびポーリングメッセージが送信された直後に呼び出されます。バーストの場合、ポーリング間隔は2秒に固定されます。さもなければ、ホストポーリング指数`hpoll`は、最後に受信したパケットからの`ppoll`およびポーリング処理からの`hpoll`の小さいほうに設定されます。ただし、`MINPOLL`以上または`MAXPOLL`以下です。したがって、クロック規律はオーバーサンプリングされることができますが、アンダーサンプリングはされません。これは、サブネットの動的動作を維持し、プロトコルエラーから保護するために必要です。

ポーリング指数は間隔に変換され、最後のポーリング時間変数に追加されると、次のポール時間変数の値が決定されます。 最後に、最後のポーリング時間変数が現在の秒カウンタに設定されます。

## 14. Simple Network Time Protocol (SNTP)

SNTPv4(Simple Network Time Protocol)[[RFC4330](https://tools.ietf.org/html/rfc4330)]と呼ばれるNTPのサブセットに準拠するプライマリサーバーとクライアントは、[9章](https://tools.ietf.org/html/rfc5905#section-9)以降で説明する緩和アルゴリズムを実装する必要はありません。SNTPは、単一のリファレンスクロックを備えたプライマリサーバー、および単一の上流サーバを持ち、従属クライアントを持たないクライアントを対象としています。完全に開発されたNTPv4の実装は、複数の上流サーバーと複数の下流サーバーまたはクライアントを持つ2次サーバーを対象としています。これらの留意事項以外に、NTPとSNTPサーバーとクライアントは完全に相互運用可能であり、NTPサブネットで混在することができます。

[8章](https://tools.ietf.org/html/rfc5905#section-8)で説明したオンラインプロトコルを実装しているSNTPプライマリサーバには、単一のリファレンスクロック以外の上流サーバはありません。原理的には、NTPプライマリサーバとは区別がつきません。これは、緩和アルゴリズムを持ち、複数の基準クロックの間を緩和することができます。

クライアント要求を受信すると、SNTPプライマリサーバは、図31で説明されているように応答パケットを構築して送信します。パケットヘッダーの分散フィールドは、[5章](https://tools.ietf.org/html/rfc5905#section-5)で説明するように更新する必要があります。

```
 +--------------------------------+
 | パケット変数  <--  変数        |
 +--------------------------------+
 | x.leap        <--  s.leap      |
 | x.version     <--  r.version   |
 | x.mode        <--  4           |
 | x.stratum     <--  s.stratum   |
 | x.poll        <--  r.poll      |
 | x.precision   <--  s.precision |
 | x.rootdelay   <--  s.rootdelay |
 | x.rootdisp    <--  s.rootdisp  |
 | x.refid       <--  s.refid     |
 | x.reftime     <--  s.reftime   |
 | x.org         <--  r.xmt       |
 | x.rec         <--  r.dst       |
 | x.xmt         <--  clock       |
 | x.keyid       <--  r.keyid     |
 | x.digest      <--  md5 digest  |
 +--------------------------------+

  図31：fast_xmitパケットヘッダー
```

オン・ワイヤー・プロトコルを実装しているSNTPクライアントには、単一のサーバーがあり、依存するクライアントはありません。これは、サーバーパケットの送信タイムスタンプのみを使用し、他のすべてのフィールドを無視する、最も簡単なアプローチであるNTPオンワイヤプロトコルの任意のサブセットで動作できます。しかし、完全なオン・ワイヤー・プロトコルを実装するための複雑さは最小限に抑えられ、完全な実装が推奨されます。

## 15. セキュリティに関する留意事項

NTPのセキュリティ要件は、他のほとんどの分散サービスよりも厳しくなっています。第1に、認証機構と時間同期機構の動作は密接に絡み合っています。信頼できる時刻同期には、指定された時間間隔にのみ有効な暗号キーが必要です。参加するサーバーとクライアントがUTCに確実に同期されている場合にのみ、時間間隔を適用することができます。さらに、NTPサブネットは性質上階層的であるため、ルートのプライマリサーバーからセカンダリサーバーを経由してリーフのクライアントに時間と信頼が流れます。

NTPクライアントは、プライマリサーバーへのパス上のすべてのサーバーが認証されている場合にのみ、依存アプリケーションへの本物の時間を持つと主張できます。NTPでは、各サーバーは下位の階層サーバーを認証し、最も低い階層(プライマリ)サーバーを誘導して認証します。NTPのコンテキストでの認証は必ずしも時間が正しいことを必ずしも意味しないことに注意することが重要です。NTPクライアントは、異なるサーバーとの多数の並行したアソシエーションを確立し、細工された合意アルゴリズムを使用して、おそらくはfalsetickersを含む集団からtruechimersを摘出します。

NTP仕様では、侵入者の目的は、偽の時間値を挿入したり、プロトコルを中断させたり、リソースを使い果たして正規のアプリケーションにサービスを拒否する偽のパケットでネットワーク、サーバー、クライアントを詰まらせることです。NTPのアーキテクチャ、プロトコル、およびアルゴリズムにはすでに数多くの防御メカニズムが組み込まれています。オンワイヤタイムスタンプ交換方式は、本質的ななりすまし、パケット損失、および再生攻撃に耐性があります。設計されたクロック・フィルタ、選択およびクラスタリング・アルゴリズムは、ビザンチン反逆者の邪悪な集団を守るために設計されています。決定された侵入者を敗北させるように必ずしも設計されているわけではありませんが、これらのアルゴリズムと付随する健全性チェックは、不適切に動作しているかもしれないが恐らくフレンドリーなシナリオを逸脱するために長期間動作しています。ただし、これらのメカニズムでは、サーバーをクライアントに対して安全に識別して認証することはできません。特別な保護を追加することなく、侵入者は次の攻撃の一部またはすべてを注入できます。

1.侵入者は永久にパケットを傍受して記録することができます。

2.侵入者は、特に高度な暗号計算を必要とする場合、サーバ、ネットワーク、またはクライアントが処理できるよりも速くパケットを生成できます。

3.盗聴攻撃では、侵入者はパケットを傍受し、変更し、再生することができます。ただし、元のパケットの転送を永続的に防止することはできません。つまり、ワイヤを壊すことはできません。嘘をつき、それを混雑させるだけです。一般に、変更されたパケットは、元のパケットの前に被害者に到着することも、サーバの秘密鍵または識別パラメータも持ちません。

4.ミドルマン攻撃またはマスカレード攻撃では、侵入者はサーバとクライアントの間に配置されるため、パケットを傍受し、変更して再生し、元のパケットの転送を防ぐことができます。ただし、仲介者にはサーバーの秘密鍵はありません。

NTPセキュリティモデルでは、次のような制限が想定されています。

1. 公開鍵アルゴリズムの実行時間は比較的長く、非常に可変である。一般に、NTPパケットごとにこれらのアルゴリズムを使用しなければならない場合、時間同期機能の性能は著しく低下します。

2. いくつかの動作モードでは、サーバがすべてのクライアントの状態変数を保持することは不可能です。 しかしながら、そのクライアントからのパケットの到着時にクライアントのためにそれらを再生成することは実現可能です。

3.暗号値の有効期間を強制する必要があり、信頼性の高いシステムクロックが必要です。ただし、システムクロックを同期させるソースは信頼できるものでなければなりません。タイムキーピング機能と認証機能のこの循環相互依存性には特別な処理が必要です。

4.クライアントのセキュリティ機能は、ネット経由で送信される公開値のみを含む必要があります。プライベート値は、この目的のために割り当てられた特別なトラステッド・エージェント(TA)の場合を除いて、作成されたマシンを超えて決して開示してはなりません。

クライアントがサーバーに対して安全に認証される必要があるSecure Shell(SSH)セキュリティモデルとは異なり、NTPではサーバーをクライアントに対して安全に認証する必要があります。SSHでは、それぞれの異なるインターフェイスアドレスを、逆DNSクエリによって返される別の名前にバインドすることができます。この設計では、別個の公開鍵/秘密鍵のペアが、それぞれのインタフェースアドレスに対して別個の名前で必要とされることがあります。この設計の利点は、インターフェイスごとにセキュリティ区画が異なる可能性があることです。これにより、たとえばファイアウォールでは、クライアントを認証するためにいくつかのインタフェースを要求したり、他のインタフェースを要求したりすることはできません。

ここに指定されたNTPの場合、NTPブロードキャストクライアントは、インターネット上の他の場所にある不正なまたは敵対的なSNTPまたはNTPブロードキャストサーバーによって中断される可能性があります。このような混乱は、いくつかのアプローチによって最小限に抑えることができます。フィルタリングは、NTPクライアントの既知または信頼できるNTPブロードキャストサーバへのアクセスを制限するために使用できます。このようなフィルタリングは、悪意のあるトラフィックがNTPクライアントに到達するのを防ぎます。クライアントでの暗号認証は、適切に署名されたNTPメッセージからのタイミング情報が、その時計の同期に利用されることを許可します。Autokeyメカニズム[[RFC5906](https://tools.ietf.org/html/rfc5906)]の使用によって、より高いレベルの認証が得られるかもしれません。

[8章](https://tools.ietf.org/html/rfc5905#section-8)では、クライアント要求の再生に関する潜在的なセキュリティの懸念について説明します。その章の推奨事項に従うことで、そのような攻撃に対する保護が提供されます。

この仕様は既存の実装を記述していることに注意してください。MD5アルゴリズムのセキュリティ不足はよく知られていますが、NTP仕様でのその使用は、インターネットコミュニティにおける広範な展開と一致しています。

## 16. IANAに関する留意事項

UDP/TCP ポート123は、このプロトコルのためにIANAによって以前に割り当てられました。IANAは、IPv4マルチキャストグループアドレス`224.0.1.1`と、IPv6マルチキャストアドレス`:101`をNTPのために割り当てています。この文書は、NTP拡張フィールドを導入して、拡張フィールド内のフィールドタイプサブフィールドによって特定の拡張が識別される将来のプロトコル拡張を可能にします。IANAは、このプロトコルに関連する拡張フィールドタイプのレジストリを確立し、維持する予定であり、このレジストリに初期エントリを設定しません。将来のニーズが発生すると、新しい拡張フィールドタイプを定義することができます。[[RFC5226](https://tools.ietf.org/html/rfc5226)]で概説された方針に従って、新しい値はIETF Reviewによって定義されるでしょう。

IANAは、NTP参照識別子コード用の新しいレジストリを作成しました。これには、[7章3節](https://tools.ietf.org/html/rfc5905#section-7.3)で定義されている現在のコードが含まれ、First-Come-First-Serve(FCFS)ベースで拡張することができます。 レジストリの形式は次のとおりです。

```
 +------+----------------------------------------------------------+
 | ID   | クロック参照源                                           |
 +------+----------------------------------------------------------+
 | GOES | 静止軌道環境衛星                                         |
 | GPS  | 全地球測位システム                                       |
 | ...  | ...                                                      |
 +------+----------------------------------------------------------+

                   図32：参照識別子コード
```

IANAはNTP Kiss-o'-Deathコード用の新しいレジストリを作成しました。これには、[7章4節](https://tools.ietf.org/html/rfc5905#section-7.4)で定義されている現在のコードが含まれ、FCFSベースで拡張することができます。 レジストリの形式は次のとおりです。

```
 +--------+------------------------------------------------------------+
 | コード |                           意味                             |
 +--------+------------------------------------------------------------+
 | ACST   | アソシエーションがユニキャストサーバーに属する             |
 | AUTH   | サーバー認証に失敗                                         |
 | ...    | ...                                                        |
 +--------+------------------------------------------------------------+

                         図33：キスコード
```

参照識別子とKiss-o'-Deathコードの両方について、IANAは実験と開発のために予約されているので、文字 "X"で始まるコードを決して割り当てないように要求されます。

## 17. 謝辞

編集者は、技術的なレビューとこの文書に対する特定のテキストの貢献について、Karen O'Donoghue、Brian Haberman、Greg Dowd、Mark Elliot、Harlan Stenn、Yaakov Stein、Stewart Bryant、Danny Mayerに感謝したい。

## 18. 参考文献

## 18.1. 引用規格

   [RFC0768]       Postel, J., "User Datagram Protocol", STD 6, [RFC 768](https://tools.ietf.org/html/rfc768), August 1980.

   [RFC0791]       Postel, J., "Internet Protocol", STD 5, [RFC 791](https://tools.ietf.org/html/rfc791), September 1981.

   [RFC0793]       Postel, J., "Transmission Control Protocol", STD 7, [RFC 793](https://tools.ietf.org/html/rfc793), September 1981.

   [RFC1321]       Rivest, R., "The MD5 Message-Digest Algorithm", [RFC 1321](https://tools.ietf.org/html/rfc1321), April 1992.

   [RFC2119]       Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", [BCP 14](https://tools.ietf.org/html/bcp14), [RFC 2119](https://tools.ietf.org/html/rfc2119), March 1997.

## 18.2. 参考資料

   [CGPM]          Bureau International des Poids et Mesures, "Comptes Rendus de la 15e CGPM", 1976.

   [ITU-R_TF.460]  International Telecommunications Union, "ITU-R TF.460 Standard-frequency and time-signal emissions", February 2002.

   [RFC1305]       Mills, D., "Network Time Protocol (Version 3) Specification, Implementation and Analysis", [RFC 1305](https://tools.ietf.org/html/rfc1305), March 1992.

   [RFC1345]       Simonsen, K., "Character Mnemonics and Character Sets", [RFC 1345](https://tools.ietf.org/html/rfc1345), June 1992.

   [RFC4330]       Mills, D., "Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI", [RFC 4330](https://tools.ietf.org/html/rfc4330), January 2006.

   [RFC5226]       Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA Considerations Section in RFCs", [BCP 26](https://tools.ietf.org/html/bcp26), [RFC 5226](https://tools.ietf.org/html/rfc5226), May 2008.

   [RFC5906]       Haberman, B., Ed. and D. Mills, "Network Time Protocol Version 4: Autokey Specification", [RFC 5906](https://tools.ietf.org/html/rfc5906), June 2010.

   [ref6]          Marzullo and S. Owicki, "Maintaining the time in a distributed system", ACM Operating Systems Review 19, July 1985.

   [ref7]          Mills, D.L., "Computer Network Time Synchronization - the Network Time Protocol", CRC Press, 304 pp, 2006.

   [ref9]          Mills, D.L., Electrical and Computer Engineering Technical Report 06-6-1, NDSS, June 2006, "Network Time Protocol Version 4 Reference and Implementation Guide", 2006.